Usage
=====

The client is actually useful for both query and submission, and
querying is safer I'll start illustrating use there.

Retrieving an experiment
------------------------

A basic use case to find information about an experiment.

.. testcode::

   from encoded_client.encoded import ENCODED

   server = ENCODED("www.encodeproject.org")
   experiment = server.get_json("ENCSR000AEG")

   print(experiment["description"])

.. testoutput::

   PolyA RNA-Seq from oligo-dT primed Total RNA on the GM12878 cell line


Searching
---------

Sometimes, however, you may not have a specific accession list of access
ids to search for and you need to look for objects.

.. testcode::

   from encoded_client.encoded import ENCODED

   server = ENCODED("www.encodeproject.org")
   query = server.search_jsonld(searchTerm="C2C12", limit=5)

   print("Results:", len(query["@graph"]))
   for row in query["@graph"]:
       print(row["@id"], row.get("description", "n/a"))

.. testoutput::

    Results: 5
    /annotations/ENCSR777WDG/ candidate Cis-Regulatory Elements in C3H C2C12 for GRCh38
    /annotations/ENCSR991QYA/ Functional validation of enhancers in C2C12 myoblast cells
    /annotations/ENCSR953JBP/ Functional validation of enhancers in C2C12 myocyte cells
    /annotations/ENCSR309JHZ/ candidate Cis-Regulatory Elements in C3H myocyte originated from C2C12 for GRCh38
    /documents/a5f5c35a-cdda-4a45-9742-22e69ff50c9c/ C2C12 cell culture, differentiation treatment, and cross-linking protocol


Using the "searchTerm" argument generates a URL exactly like entering
the query into the search box on the https://www.encodeproject.org
website. The limit argument is optional and the default is to return
25 records. I shortened it for this example.

Additionally when doing programatic access, you are likely to want to
use limit="all" instead.


Submitting
----------

Here's a block from one of my submission notebooks, preparing to
submit a Biosamples page.

load_netrc() and authentication.
................................

Actually posting data (or accessing unreleased data) requires access
tokens provided by the DCC. I frequently run this code on servers so I
didn't want to use the desktop orientated keyring project. So I used
the old .netrc files as the Python standard library included a parser.

To use this as a place to hold credentials you'll need to create a
file `.netrc` in the root of your user directory.

The format is

.. code-block::

   machine <hostname>
   login <username>
   password <password>

Though you can put them all on one line if you'd like.

Example Submission
..................

This is just of the Biosample object, which is the object with the
fewest dependencies on other objects.

You'll need to do something similar for the other common objects,
Experiments, Libraries, Replicates, and Files.

In this case I'm reading from an odf file, so the pandas.read_excel
call has encine="odf" in it, for excel you can leave the engine
argument off, and `gcat <https:https://github.com/detrout/gcat>`_'s
syntax is different.

The column names end up being the field names for the JSON objects
generated by the code, with the additional constraint that there is a
way to set the type of a column by adding :type name.

Most frquently I need :array to indicate that certian values are
actually intended to be a list of types, but I also use :date, and
:integer.


.. code-block:: python

    import pandas
    from encoded_client.encoded import ENCODED, DCCValidator

    server = ENCODED("test.encodedcc.org")
    server.load_netrc()
    validator = DCCValidator(server)
    
    biosample = pandas.read_excel(
                   spreadsheet_name,
                   sheet_name='Biosamples',
                   header=0,
                   engine='odf')

    created = server.post_sheet('/biosamples/',
                                verbose=True,
                                dry_run=True,
                                validator=validator)

    if created:
        biosample.to_excel("biosamples-created.xlsx", index=False)
