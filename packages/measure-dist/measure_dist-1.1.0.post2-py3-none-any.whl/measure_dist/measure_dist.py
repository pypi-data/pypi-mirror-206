
# python wrapper for package measure_dist within overall package measure_dist
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy build -output=measure_dist -vm=/home/gmnx/.pyenv/versions/3.6.15/bin/python3.6 .

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
    import collections.abc as _collections_abc
except ImportError:
    _collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _measure_dist
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from measure_dist import measure_dist
# and then refer to everything using measure_dist. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for slice [][]float64
class Slice_Slice_float64(go.GoClass):
    """"""
    def __init__(self, *args, **kwargs):
        """
        handle=A Go-side object is always initialized with an explicit handle=arg
        otherwise parameter is a python list that we copy from
        """
        self.index = 0
        if len(kwargs) == 1 and 'handle' in kwargs:
            self.handle = kwargs['handle']
            _measure_dist.IncRef(self.handle)
        elif len(args) == 1 and isinstance(args[0], go.GoClass):
            self.handle = args[0].handle
            _measure_dist.IncRef(self.handle)
        else:
            self.handle = _measure_dist.Slice_Slice_float64_CTor()
            _measure_dist.IncRef(self.handle)
            if len(args) > 0:
                if not isinstance(args[0], _collections_abc.Iterable):
                    raise TypeError('Slice_Slice_float64.__init__ takes a sequence as argument')
                for elt in args[0]:
                    self.append(elt)
    def __del__(self):
        _measure_dist.DecRef(self.handle)
    def __str__(self):
        s = 'measure_dist.Slice_Slice_float64 len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
        if len(self) < 120:
            s += ', '.join(map(str, self)) + ']'
        return s
    def __repr__(self):
        return 'measure_dist.Slice_Slice_float64([' + ', '.join(map(str, self)) + '])'
    def __len__(self):
        return _measure_dist.Slice_Slice_float64_len(self.handle)
    def __getitem__(self, key):
        if isinstance(key, slice):
            if key.step == None or key.step == 1:
                st = key.start
                ed = key.stop
                if st == None:
                    st = 0
                if ed == None:
                    ed = _measure_dist.Slice_Slice_float64_len(self.handle)
                return Slice_Slice_float64(handle=_measure_dist.Slice_Slice_float64_subslice(self.handle, st, ed))
            return [self[ii] for ii in range(*key.indices(len(self)))]
        elif isinstance(key, int):
            if key < 0:
                key += len(self)
            if key < 0 or key >= len(self):
                raise IndexError('slice index out of range')
            return go.Slice_float64(handle=_measure_dist.Slice_Slice_float64_elem(self.handle, key))
        else:
            raise TypeError('slice index invalid type')
    def __setitem__(self, idx, value):
        if idx < 0:
            idx += len(self)
        if idx < len(self):
            _measure_dist.Slice_Slice_float64_set(self.handle, idx, value.handle)
            return
        raise IndexError('slice index out of range')
    def __iadd__(self, value):
        if not isinstance(value, _collections_abc.Iterable):
            raise TypeError('Slice_Slice_float64.__iadd__ takes a sequence as argument')
        for elt in value:
            self.append(elt)
        return self
    def __iter__(self):
        self.index = 0
        return self
    def __next__(self):
        if self.index < len(self):
            rv = _measure_dist.Slice_Slice_float64_elem(self.handle, self.index)
            self.index = self.index + 1
            return rv
        raise StopIteration
    def append(self, value):
        go_val = go.Slice_float64(value)
        _measure_dist.Slice_Slice_float64_append(self.handle, go_val.handle)
    def copy(self, src):
        """ copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
        mx = min(len(self), len(src))
        for i in range(mx):
            self[i] = src[i]

# Python type for slice []measure_dist.Object
class Slice_measure_dist_Object(go.GoClass):
    """"""
    def __init__(self, *args, **kwargs):
        """
        handle=A Go-side object is always initialized with an explicit handle=arg
        otherwise parameter is a python list that we copy from
        """
        self.index = 0
        if len(kwargs) == 1 and 'handle' in kwargs:
            self.handle = kwargs['handle']
            _measure_dist.IncRef(self.handle)
        elif len(args) == 1 and isinstance(args[0], go.GoClass):
            self.handle = args[0].handle
            _measure_dist.IncRef(self.handle)
        else:
            self.handle = _measure_dist.Slice_measure_dist_Object_CTor()
            _measure_dist.IncRef(self.handle)
            if len(args) > 0:
                if not isinstance(args[0], _collections_abc.Iterable):
                    raise TypeError('Slice_measure_dist_Object.__init__ takes a sequence as argument')
                for elt in args[0]:
                    self.append(elt)
    def __del__(self):
        _measure_dist.DecRef(self.handle)
    def __str__(self):
        s = 'measure_dist.Slice_measure_dist_Object len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
        if len(self) < 120:
            s += ', '.join(map(str, self)) + ']'
        return s
    def __repr__(self):
        return 'measure_dist.Slice_measure_dist_Object([' + ', '.join(map(str, self)) + '])'
    def __len__(self):
        return _measure_dist.Slice_measure_dist_Object_len(self.handle)
    def __getitem__(self, key):
        if isinstance(key, slice):
            if key.step == None or key.step == 1:
                st = key.start
                ed = key.stop
                if st == None:
                    st = 0
                if ed == None:
                    ed = _measure_dist.Slice_measure_dist_Object_len(self.handle)
                return Slice_measure_dist_Object(handle=_measure_dist.Slice_measure_dist_Object_subslice(self.handle, st, ed))
            return [self[ii] for ii in range(*key.indices(len(self)))]
        elif isinstance(key, int):
            if key < 0:
                key += len(self)
            if key < 0 or key >= len(self):
                raise IndexError('slice index out of range')
            return dist_Object(handle=_measure_dist.Slice_measure_dist_Object_elem(self.handle, key))
        else:
            raise TypeError('slice index invalid type')
    def __setitem__(self, idx, value):
        if idx < 0:
            idx += len(self)
        if idx < len(self):
            _measure_dist.Slice_measure_dist_Object_set(self.handle, idx, value.handle)
            return
        raise IndexError('slice index out of range')
    def __iadd__(self, value):
        if not isinstance(value, _collections_abc.Iterable):
            raise TypeError('Slice_measure_dist_Object.__iadd__ takes a sequence as argument')
        for elt in value:
            self.append(elt)
        return self
    def __iter__(self):
        self.index = 0
        return self
    def __next__(self):
        if self.index < len(self):
            rv = _measure_dist.Slice_measure_dist_Object_elem(self.handle, self.index)
            self.index = self.index + 1
            return rv
        raise StopIteration
    def append(self, value):
        _measure_dist.Slice_measure_dist_Object_append(self.handle, value.handle)
    def copy(self, src):
        """ copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
        mx = min(len(self), len(src))
        for i in range(mx):
            self[i] = src[i]


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---


# ---- Structs ---

# Python type for struct measure_dist.Annotation
class Annotation(go.GoClass):
    """"""
    def __init__(self, *args, **kwargs):
        """
        handle=A Go-side object is always initialized with an explicit handle=arg
        otherwise parameters can be unnamed in order of field names or named fields
        in which case a new Go object is constructed first
        """
        if len(kwargs) == 1 and 'handle' in kwargs:
            self.handle = kwargs['handle']
            _measure_dist.IncRef(self.handle)
        elif len(args) == 1 and isinstance(args[0], go.GoClass):
            self.handle = args[0].handle
            _measure_dist.IncRef(self.handle)
        else:
            self.handle = _measure_dist.measure_dist_Annotation_CTor()
            _measure_dist.IncRef(self.handle)
            if  0 < len(args):
                self.XMLName = args[0]
            if "XMLName" in kwargs:
                self.XMLName = kwargs["XMLName"]
            if  1 < len(args):
                self.Object = args[1]
            if "Object" in kwargs:
                self.Object = kwargs["Object"]
    def __del__(self):
        _measure_dist.DecRef(self.handle)
    def __str__(self):
        pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
        sv = 'measure_dist.Annotation{'
        first = True
        for v in pr:
            if callable(v[1]):
                continue
            if first:
                first = False
            else:
                sv += ', '
            sv += v[0] + '=' + str(v[1])
        return sv + '}'
    def __repr__(self):
        pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
        sv = 'measure_dist.Annotation ( '
        for v in pr:
            if not callable(v[1]):
                sv += v[0] + '=' + str(v[1]) + ', '
        return sv + ')'
    @property
    def XMLName(self):
        return go.xml_Name(handle=_measure_dist.measure_dist_Annotation_XMLName_Get(self.handle))
    @XMLName.setter
    def XMLName(self, value):
        if isinstance(value, go.GoClass):
            _measure_dist.measure_dist_Annotation_XMLName_Set(self.handle, value.handle)
        else:
            raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
    @property
    def Object(self):
        return Slice_measure_dist_Object(handle=_measure_dist.measure_dist_Annotation_Object_Get(self.handle))
    @Object.setter
    def Object(self, value):
        if isinstance(value, go.GoClass):
            _measure_dist.measure_dist_Annotation_Object_Set(self.handle, value.handle)
        else:
            raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct measure_dist.AnnotationResult
class AnnotationResult(go.GoClass):
    """"""
    def __init__(self, *args, **kwargs):
        """
        handle=A Go-side object is always initialized with an explicit handle=arg
        otherwise parameters can be unnamed in order of field names or named fields
        in which case a new Go object is constructed first
        """
        if len(kwargs) == 1 and 'handle' in kwargs:
            self.handle = kwargs['handle']
            _measure_dist.IncRef(self.handle)
        elif len(args) == 1 and isinstance(args[0], go.GoClass):
            self.handle = args[0].handle
            _measure_dist.IncRef(self.handle)
        else:
            self.handle = _measure_dist.measure_dist_AnnotationResult_CTor()
            _measure_dist.IncRef(self.handle)
            if  0 < len(args):
                self.List_object_names = args[0]
            if "List_object_names" in kwargs:
                self.List_object_names = kwargs["List_object_names"]
            if  1 < len(args):
                self.List_with_all_boxes = args[1]
            if "List_with_all_boxes" in kwargs:
                self.List_with_all_boxes = kwargs["List_with_all_boxes"]
    def __del__(self):
        _measure_dist.DecRef(self.handle)
    def __str__(self):
        pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
        sv = 'measure_dist.AnnotationResult{'
        first = True
        for v in pr:
            if callable(v[1]):
                continue
            if first:
                first = False
            else:
                sv += ', '
            sv += v[0] + '=' + str(v[1])
        return sv + '}'
    def __repr__(self):
        pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
        sv = 'measure_dist.AnnotationResult ( '
        for v in pr:
            if not callable(v[1]):
                sv += v[0] + '=' + str(v[1]) + ', '
        return sv + ')'
    @property
    def List_object_names(self):
        return go.Slice_string(handle=_measure_dist.measure_dist_AnnotationResult_List_object_names_Get(self.handle))
    @List_object_names.setter
    def List_object_names(self, value):
        if isinstance(value, go.GoClass):
            _measure_dist.measure_dist_AnnotationResult_List_object_names_Set(self.handle, value.handle)
        else:
            raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
    @property
    def List_with_all_boxes(self):
        return go.Slice_int(handle=_measure_dist.measure_dist_AnnotationResult_List_with_all_boxes_Get(self.handle))
    @List_with_all_boxes.setter
    def List_with_all_boxes(self, value):
        if isinstance(value, go.GoClass):
            _measure_dist.measure_dist_AnnotationResult_List_with_all_boxes_Set(self.handle, value.handle)
        else:
            raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct measure_dist.BndBox
class BndBox(go.GoClass):
    """"""
    def __init__(self, *args, **kwargs):
        """
        handle=A Go-side object is always initialized with an explicit handle=arg
        otherwise parameters can be unnamed in order of field names or named fields
        in which case a new Go object is constructed first
        """
        if len(kwargs) == 1 and 'handle' in kwargs:
            self.handle = kwargs['handle']
            _measure_dist.IncRef(self.handle)
        elif len(args) == 1 and isinstance(args[0], go.GoClass):
            self.handle = args[0].handle
            _measure_dist.IncRef(self.handle)
        else:
            self.handle = _measure_dist.measure_dist_BndBox_CTor()
            _measure_dist.IncRef(self.handle)
            if  0 < len(args):
                self.XMin = args[0]
            if "XMin" in kwargs:
                self.XMin = kwargs["XMin"]
            if  1 < len(args):
                self.YMin = args[1]
            if "YMin" in kwargs:
                self.YMin = kwargs["YMin"]
            if  2 < len(args):
                self.XMax = args[2]
            if "XMax" in kwargs:
                self.XMax = kwargs["XMax"]
            if  3 < len(args):
                self.YMax = args[3]
            if "YMax" in kwargs:
                self.YMax = kwargs["YMax"]
    def __del__(self):
        _measure_dist.DecRef(self.handle)
    def __str__(self):
        pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
        sv = 'measure_dist.BndBox{'
        first = True
        for v in pr:
            if callable(v[1]):
                continue
            if first:
                first = False
            else:
                sv += ', '
            sv += v[0] + '=' + str(v[1])
        return sv + '}'
    def __repr__(self):
        pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
        sv = 'measure_dist.BndBox ( '
        for v in pr:
            if not callable(v[1]):
                sv += v[0] + '=' + str(v[1]) + ', '
        return sv + ')'
    @property
    def XMin(self):
        return _measure_dist.measure_dist_BndBox_XMin_Get(self.handle)
    @XMin.setter
    def XMin(self, value):
        if isinstance(value, go.GoClass):
            _measure_dist.measure_dist_BndBox_XMin_Set(self.handle, value.handle)
        else:
            _measure_dist.measure_dist_BndBox_XMin_Set(self.handle, value)
    @property
    def YMin(self):
        return _measure_dist.measure_dist_BndBox_YMin_Get(self.handle)
    @YMin.setter
    def YMin(self, value):
        if isinstance(value, go.GoClass):
            _measure_dist.measure_dist_BndBox_YMin_Set(self.handle, value.handle)
        else:
            _measure_dist.measure_dist_BndBox_YMin_Set(self.handle, value)
    @property
    def XMax(self):
        return _measure_dist.measure_dist_BndBox_XMax_Get(self.handle)
    @XMax.setter
    def XMax(self, value):
        if isinstance(value, go.GoClass):
            _measure_dist.measure_dist_BndBox_XMax_Set(self.handle, value.handle)
        else:
            _measure_dist.measure_dist_BndBox_XMax_Set(self.handle, value)
    @property
    def YMax(self):
        return _measure_dist.measure_dist_BndBox_YMax_Get(self.handle)
    @YMax.setter
    def YMax(self, value):
        if isinstance(value, go.GoClass):
            _measure_dist.measure_dist_BndBox_YMax_Set(self.handle, value.handle)
        else:
            _measure_dist.measure_dist_BndBox_YMax_Set(self.handle, value)

# Python type for struct measure_dist.Object
class Object(go.GoClass):
    """"""
    def __init__(self, *args, **kwargs):
        """
        handle=A Go-side object is always initialized with an explicit handle=arg
        otherwise parameters can be unnamed in order of field names or named fields
        in which case a new Go object is constructed first
        """
        if len(kwargs) == 1 and 'handle' in kwargs:
            self.handle = kwargs['handle']
            _measure_dist.IncRef(self.handle)
        elif len(args) == 1 and isinstance(args[0], go.GoClass):
            self.handle = args[0].handle
            _measure_dist.IncRef(self.handle)
        else:
            self.handle = _measure_dist.measure_dist_Object_CTor()
            _measure_dist.IncRef(self.handle)
            if  0 < len(args):
                self.Name = args[0]
            if "Name" in kwargs:
                self.Name = kwargs["Name"]
            if  1 < len(args):
                self.BndBox = args[1]
            if "BndBox" in kwargs:
                self.BndBox = kwargs["BndBox"]
    def __del__(self):
        _measure_dist.DecRef(self.handle)
    def __str__(self):
        pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
        sv = 'measure_dist.Object{'
        first = True
        for v in pr:
            if callable(v[1]):
                continue
            if first:
                first = False
            else:
                sv += ', '
            sv += v[0] + '=' + str(v[1])
        return sv + '}'
    def __repr__(self):
        pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
        sv = 'measure_dist.Object ( '
        for v in pr:
            if not callable(v[1]):
                sv += v[0] + '=' + str(v[1]) + ', '
        return sv + ')'
    @property
    def Name(self):
        return _measure_dist.measure_dist_Object_Name_Get(self.handle)
    @Name.setter
    def Name(self, value):
        if isinstance(value, go.GoClass):
            _measure_dist.measure_dist_Object_Name_Set(self.handle, value.handle)
        else:
            _measure_dist.measure_dist_Object_Name_Set(self.handle, value)
    @property
    def BndBox(self):
        return dist_BndBox(handle=_measure_dist.measure_dist_Object_BndBox_Get(self.handle))
    @BndBox.setter
    def BndBox(self, value):
        if isinstance(value, go.GoClass):
            _measure_dist.measure_dist_Object_BndBox_Set(self.handle, value.handle)
        else:
            raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---


# ---- Functions ---
def calculate_iou(boxA, boxB):
    """CalculateIOU([]int boxA, []int boxB) float"""
    go_boxA = go.Slice_int(boxA)
    go_boxB = go.Slice_int(boxB)
    return _measure_dist.measure_dist_CalculateIOU(go_boxA.handle, go_boxB.handle)
def enlarge_area(area, margin, imageWidth, imageHeight):
    """EnlargeArea([]int area, int margin, int imageWidth, int imageHeight) []int"""
    go_area = go.Slice_int(area)
    return go.Slice_int(handle=_measure_dist.measure_dist_EnlargeArea(go_area.handle, margin, imageWidth, imageHeight))
def is_inside_area(objectBox, area):
    """IsInsideArea([]int objectBox, []int area) bool"""
    go_objectBox = go.Slice_int(objectBox)
    go_area = go.Slice_int(area)
    return _measure_dist.measure_dist_IsInsideArea(go_objectBox.handle, go_area.handle)
def merge_boxes(box1, box2):
    """MergeBoxes([]int box1, []int box2) []int"""
    go_box1 = go.Slice_int(box1)
    go_box2 = go.Slice_int(box2)
    return go.Slice_int(handle=_measure_dist.measure_dist_MergeBoxes(go_box1.handle, go_box2.handle))
def xywh_to_xyxy(iCrop):
    """XywhToXyxy([]int iCrop) []int"""
    go_iCrop = go.Slice_int(iCrop)
    return go.Slice_int(handle=_measure_dist.measure_dist_XywhToXyxy(go_iCrop.handle))
def calculate_area(box):
    """CalculateArea([]int box) int"""
    go_box = go.Slice_int(box)
    return _measure_dist.measure_dist_CalculateArea(go_box.handle)
def coordinate_to_azimuth(coordinate):
    """CoordinateToAzimuth([]float coordinate) float"""
    go_coordinate = go.Slice_float64(coordinate)
    return _measure_dist.measure_dist_CoordinateToAzimuth(go_coordinate.handle)
def three_p_center_point(mesh):
    """ThreePCenterPoint([][]float mesh) []float"""
    go_mesh = Slice_Slice_float64(mesh.tolist())
    return go.Slice_float64(handle=_measure_dist.measure_dist_ThreePCenterPoint(go_mesh.handle))
def two_p_center_point(mesh):
    """TwoPCenterPoint([][]float mesh) []float"""
    go_mesh = Slice_Slice_float64(mesh.tolist())
    return go.Slice_float64(handle=_measure_dist.measure_dist_TwoPCenterPoint(go_mesh.handle))
def read_annotation(xmlFile):
    """ReadAnnotation(str xmlFile) object"""
    result = AnnotationResult(handle=_measure_dist.measure_dist_ReadAnnotation(xmlFile))
    list_with_all_boxes = result.List_with_all_boxes
    list_object_names = result.List_object_names
    names = []
    boxes = []

    for i, name in enumerate(list_object_names):
        names.append(name)
        xmin = list_with_all_boxes[i*4]
        ymin = list_with_all_boxes[i*4+1]
        xmax = list_with_all_boxes[i*4+2]
        ymax = list_with_all_boxes[i*4+3]
        dict_with_single_boxes = {"xmin":xmin, "ymin":ymin, "xmax":xmax, "ymax":ymax}
        boxes.append(dict_with_single_boxes)

    return names, boxes


