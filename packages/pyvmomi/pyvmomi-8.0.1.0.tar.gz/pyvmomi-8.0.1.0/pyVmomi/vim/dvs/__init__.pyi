from typing import List
from enum import Enum
from pyVmomi import vim, vmodl
from datetime import datetime
from pyVmomi.VmomiSupport import ManagedObject, binary, long


class DistributedVirtualPortgroup(vim.Network):
    @property
    def key(self) -> str: ...
    @property
    def config(self) -> DistributedVirtualPortgroup.ConfigInfo: ...
    @property
    def portKeys(self) -> List[str]: ...
    def Reconfigure(self, spec: DistributedVirtualPortgroup.ConfigSpec) -> vim.Task: ...
    def Rollback(self, entityBackup: EntityBackup.Config) -> vim.Task: ...


    class NsxPortgroupOperationResult(vmodl.DynamicData):
        @property
        def portgroups(self) -> List[DistributedVirtualPortgroup]: ...
        @property
        def problems(self) -> List[DistributedVirtualPortgroup.Problem]: ...


    class PortgroupPolicy(vmodl.DynamicData):
        @property
        def blockOverrideAllowed(self) -> bool: ...
        @property
        def shapingOverrideAllowed(self) -> bool: ...
        @property
        def vendorConfigOverrideAllowed(self) -> bool: ...
        @property
        def livePortMovingAllowed(self) -> bool: ...
        @property
        def portConfigResetAtDisconnect(self) -> bool: ...
        @property
        def networkResourcePoolOverrideAllowed(self) -> bool: ...
        @property
        def trafficFilterOverrideAllowed(self) -> bool: ...


    class Problem(vmodl.DynamicData):
        @property
        def logicalSwitchUuid(self) -> str: ...
        @property
        def fault(self) -> vmodl.MethodFault: ...


    class BackingType(Enum):
        standard = "standard"
        nsx = "nsx"


    class MetaTagName(Enum):
        dvsName = "dvsname"
        portgroupName = "portgroupname"
        portIndex = "portindex"


    class PortgroupType(Enum):
        earlyBinding = "earlybinding"
        lateBinding = "latebinding"
        ephemeral = "ephemeral"


class DistributedVirtualSwitchManager(ManagedObject):
    def QuerySupportedSwitchSpec(self, recommended: bool) -> List[ProductSpec]: ...
    def QuerySupportedNetworkOffloadSpec(self, switchProductSpec: ProductSpec) -> List[NetworkOffloadSpec]: ...
    def QueryCompatibleVmnicsFromHosts(self, hosts: List[vim.HostSystem], dvs: vim.DistributedVirtualSwitch) -> List[DistributedVirtualSwitchManager.PhysicalNicsList]: ...
    def QueryCompatibleHostForNewDvs(self, container: vim.ManagedEntity, recursive: bool, switchProductSpec: ProductSpec) -> List[vim.HostSystem]: ...
    def QueryCompatibleHostForExistingDvs(self, container: vim.ManagedEntity, recursive: bool, dvs: vim.DistributedVirtualSwitch) -> List[vim.HostSystem]: ...
    def QueryCompatibleHostSpec(self, switchProductSpec: ProductSpec) -> List[HostProductSpec]: ...
    def QueryFeatureCapability(self, switchProductSpec: ProductSpec) -> vim.DistributedVirtualSwitch.FeatureCapability: ...
    def QuerySwitchByUuid(self, uuid: str) -> vim.DistributedVirtualSwitch: ...
    def QueryDvsConfigTarget(self, host: vim.HostSystem, dvs: vim.DistributedVirtualSwitch) -> DistributedVirtualSwitchManager.DvsConfigTarget: ...
    def CheckCompatibility(self, hostContainer: DistributedVirtualSwitchManager.HostContainer, dvsProductSpec: DistributedVirtualSwitchManager.DvsProductSpec, hostFilterSpec: List[DistributedVirtualSwitchManager.HostDvsFilterSpec]) -> List[DistributedVirtualSwitchManager.CompatibilityResult]: ...
    def RectifyHost(self, hosts: List[vim.HostSystem]) -> vim.Task: ...
    def ExportEntity(self, selectionSet: List[vim.SelectionSet]) -> vim.Task: ...
    def ImportEntity(self, entityBackup: List[EntityBackup.Config], importType: str) -> vim.Task: ...
    def LookupPortgroup(self, switchUuid: str, portgroupKey: str) -> DistributedVirtualPortgroup: ...


    class CompatibilityResult(vmodl.DynamicData):
        @property
        def host(self) -> vim.HostSystem: ...
        @property
        def error(self) -> List[vmodl.MethodFault]: ...


    class DvsConfigTarget(vmodl.DynamicData):
        @property
        def distributedVirtualPortgroup(self) -> List[DistributedVirtualPortgroupInfo]: ...
        @property
        def distributedVirtualSwitch(self) -> List[DistributedVirtualSwitchInfo]: ...


    class DvsProductSpec(vmodl.DynamicData):
        @property
        def newSwitchProductSpec(self) -> ProductSpec: ...
        @property
        def distributedVirtualSwitch(self) -> vim.DistributedVirtualSwitch: ...


    class HostArrayFilter(DistributedVirtualSwitchManager.HostDvsFilterSpec):
        @property
        def host(self) -> List[vim.HostSystem]: ...


    class HostContainer(vmodl.DynamicData):
        @property
        def container(self) -> vim.ManagedEntity: ...
        @property
        def recursive(self) -> bool: ...


    class HostContainerFilter(DistributedVirtualSwitchManager.HostDvsFilterSpec):
        @property
        def hostContainer(self) -> DistributedVirtualSwitchManager.HostContainer: ...


    class HostDvsFilterSpec(vmodl.DynamicData):
        @property
        def inclusive(self) -> bool: ...


    class HostDvsMembershipFilter(DistributedVirtualSwitchManager.HostDvsFilterSpec):
        @property
        def distributedVirtualSwitch(self) -> vim.DistributedVirtualSwitch: ...


    class ImportResult(vmodl.DynamicData):
        @property
        def distributedVirtualSwitch(self) -> List[vim.DistributedVirtualSwitch]: ...
        @property
        def distributedVirtualPortgroup(self) -> List[DistributedVirtualPortgroup]: ...
        @property
        def importFault(self) -> List[vim.fault.ImportOperationBulkFault.FaultOnImport]: ...


    class PhysicalNicsList(vmodl.DynamicData):
        @property
        def host(self) -> vim.HostSystem: ...
        @property
        def physicalNics(self) -> List[vim.host.PhysicalNic]: ...


class VmwareDistributedVirtualSwitch(vim.DistributedVirtualSwitch):
    def UpdateLacpGroupConfig(self, lacpGroupSpec: List[VmwareDistributedVirtualSwitch.LacpGroupSpec]) -> vim.Task: ...


    class DpuFeatureCapability(vmodl.DynamicData):
        @property
        def networkOffloadSupported(self) -> bool: ...


    class FailureCriteria(vim.InheritablePolicy):
        @property
        def checkSpeed(self) -> vim.StringPolicy: ...
        @property
        def speed(self) -> vim.IntPolicy: ...
        @property
        def checkDuplex(self) -> vim.BoolPolicy: ...
        @property
        def fullDuplex(self) -> vim.BoolPolicy: ...
        @property
        def checkErrorPercent(self) -> vim.BoolPolicy: ...
        @property
        def percentage(self) -> vim.IntPolicy: ...
        @property
        def checkBeacon(self) -> vim.BoolPolicy: ...


    class FeatureCapability(vim.DistributedVirtualSwitch.FeatureCapability):
        @property
        def vspanSupported(self) -> bool: ...
        @property
        def lldpSupported(self) -> bool: ...
        @property
        def ipfixSupported(self) -> bool: ...
        @property
        def ipfixCapability(self) -> VmwareDistributedVirtualSwitch.IpfixFeatureCapability: ...
        @property
        def multicastSnoopingSupported(self) -> bool: ...
        @property
        def vspanCapability(self) -> VmwareDistributedVirtualSwitch.VspanFeatureCapability: ...
        @property
        def lacpCapability(self) -> VmwareDistributedVirtualSwitch.LacpFeatureCapability: ...
        @property
        def dpuCapability(self) -> VmwareDistributedVirtualSwitch.DpuFeatureCapability: ...
        @property
        def nsxSupported(self) -> bool: ...
        @property
        def mtuCapability(self) -> VmwareDistributedVirtualSwitch.MtuCapability: ...


    class IpfixConfig(vmodl.DynamicData):
        @property
        def collectorIpAddress(self) -> str: ...
        @property
        def collectorPort(self) -> int: ...
        @property
        def observationDomainId(self) -> long: ...
        @property
        def activeFlowTimeout(self) -> int: ...
        @property
        def idleFlowTimeout(self) -> int: ...
        @property
        def samplingRate(self) -> int: ...
        @property
        def internalFlowsOnly(self) -> bool: ...


    class IpfixFeatureCapability(vmodl.DynamicData):
        @property
        def ipfixSupported(self) -> bool: ...
        @property
        def ipv6ForIpfixSupported(self) -> bool: ...
        @property
        def observationDomainIdSupported(self) -> bool: ...


    class LacpFeatureCapability(vmodl.DynamicData):
        @property
        def lacpSupported(self) -> bool: ...
        @property
        def multiLacpGroupSupported(self) -> bool: ...
        @property
        def lacpFastModeSupported(self) -> bool: ...


    class LacpGroupConfig(vmodl.DynamicData):
        @property
        def key(self) -> str: ...
        @property
        def name(self) -> str: ...
        @property
        def mode(self) -> str: ...
        @property
        def uplinkNum(self) -> int: ...
        @property
        def loadbalanceAlgorithm(self) -> str: ...
        @property
        def vlan(self) -> VmwareDistributedVirtualSwitch.LagVlanConfig: ...
        @property
        def ipfix(self) -> VmwareDistributedVirtualSwitch.LagIpfixConfig: ...
        @property
        def uplinkName(self) -> List[str]: ...
        @property
        def uplinkPortKey(self) -> List[str]: ...
        @property
        def timeoutMode(self) -> str: ...


    class LacpGroupSpec(vmodl.DynamicData):
        @property
        def lacpGroupConfig(self) -> VmwareDistributedVirtualSwitch.LacpGroupConfig: ...
        @property
        def operation(self) -> str: ...


    class LagIpfixConfig(vmodl.DynamicData):
        @property
        def ipfixEnabled(self) -> bool: ...


    class LagVlanConfig(vmodl.DynamicData):
        @property
        def vlanId(self) -> List[vim.NumericRange]: ...


    class MacLearningPolicy(vim.InheritablePolicy):
        @property
        def enabled(self) -> bool: ...
        @property
        def allowUnicastFlooding(self) -> bool: ...
        @property
        def limit(self) -> int: ...
        @property
        def limitPolicy(self) -> str: ...


    class MacManagementPolicy(vim.InheritablePolicy):
        @property
        def allowPromiscuous(self) -> bool: ...
        @property
        def macChanges(self) -> bool: ...
        @property
        def forgedTransmits(self) -> bool: ...
        @property
        def macLearningPolicy(self) -> VmwareDistributedVirtualSwitch.MacLearningPolicy: ...


    class MtuCapability(vmodl.DynamicData):
        @property
        def minMtuSupported(self) -> int: ...
        @property
        def maxMtuSupported(self) -> int: ...


    class MtuHealthCheckResult(HostMember.UplinkHealthCheckResult):
        @property
        def mtuMismatch(self) -> bool: ...
        @property
        def vlanSupportSwitchMtu(self) -> List[vim.NumericRange]: ...
        @property
        def vlanNotSupportSwitchMtu(self) -> List[vim.NumericRange]: ...


    class PvlanConfigSpec(vmodl.DynamicData):
        @property
        def pvlanEntry(self) -> VmwareDistributedVirtualSwitch.PvlanMapEntry: ...
        @property
        def operation(self) -> str: ...


    class PvlanMapEntry(vmodl.DynamicData):
        @property
        def primaryVlanId(self) -> int: ...
        @property
        def secondaryVlanId(self) -> int: ...
        @property
        def pvlanType(self) -> str: ...


    class PvlanSpec(VmwareDistributedVirtualSwitch.VlanSpec):
        @property
        def pvlanId(self) -> int: ...


    class SecurityPolicy(vim.InheritablePolicy):
        @property
        def allowPromiscuous(self) -> vim.BoolPolicy: ...
        @property
        def macChanges(self) -> vim.BoolPolicy: ...
        @property
        def forgedTransmits(self) -> vim.BoolPolicy: ...


    class TeamingHealthCheckConfig(VmwareDistributedVirtualSwitch.VmwareHealthCheckConfig): ...


    class TeamingHealthCheckResult(HostMember.HealthCheckResult):
        @property
        def teamingStatus(self) -> str: ...


    class TrunkVlanSpec(VmwareDistributedVirtualSwitch.VlanSpec):
        @property
        def vlanId(self) -> List[vim.NumericRange]: ...


    class UplinkLacpPolicy(vim.InheritablePolicy):
        @property
        def enable(self) -> vim.BoolPolicy: ...
        @property
        def mode(self) -> vim.StringPolicy: ...


    class UplinkPortOrderPolicy(vim.InheritablePolicy):
        @property
        def activeUplinkPort(self) -> List[str]: ...
        @property
        def standbyUplinkPort(self) -> List[str]: ...


    class UplinkPortTeamingPolicy(vim.InheritablePolicy):
        @property
        def policy(self) -> vim.StringPolicy: ...
        @property
        def reversePolicy(self) -> vim.BoolPolicy: ...
        @property
        def notifySwitches(self) -> vim.BoolPolicy: ...
        @property
        def rollingOrder(self) -> vim.BoolPolicy: ...
        @property
        def failureCriteria(self) -> VmwareDistributedVirtualSwitch.FailureCriteria: ...
        @property
        def uplinkPortOrder(self) -> VmwareDistributedVirtualSwitch.UplinkPortOrderPolicy: ...


    class VMwarePortgroupPolicy(DistributedVirtualPortgroup.PortgroupPolicy):
        @property
        def vlanOverrideAllowed(self) -> bool: ...
        @property
        def uplinkTeamingOverrideAllowed(self) -> bool: ...
        @property
        def securityPolicyOverrideAllowed(self) -> bool: ...
        @property
        def ipfixOverrideAllowed(self) -> bool: ...
        @property
        def macManagementOverrideAllowed(self) -> bool: ...


    class VlanHealthCheckResult(HostMember.UplinkHealthCheckResult):
        @property
        def trunkedVlan(self) -> List[vim.NumericRange]: ...
        @property
        def untrunkedVlan(self) -> List[vim.NumericRange]: ...


    class VlanIdSpec(VmwareDistributedVirtualSwitch.VlanSpec):
        @property
        def vlanId(self) -> int: ...


    class VlanMtuHealthCheckConfig(VmwareDistributedVirtualSwitch.VmwareHealthCheckConfig): ...


    class VlanSpec(vim.InheritablePolicy): ...


    class VmwareHealthCheckConfig(vim.DistributedVirtualSwitch.HealthCheckConfig): ...


    class VmwareHealthCheckFeatureCapability(vim.DistributedVirtualSwitch.HealthCheckFeatureCapability):
        @property
        def vlanMtuSupported(self) -> bool: ...
        @property
        def teamingSupported(self) -> bool: ...


    class VmwarePortConfigPolicy(DistributedVirtualPort.Setting):
        @property
        def vlan(self) -> VmwareDistributedVirtualSwitch.VlanSpec: ...
        @property
        def qosTag(self) -> vim.IntPolicy: ...
        @property
        def uplinkTeamingPolicy(self) -> VmwareDistributedVirtualSwitch.UplinkPortTeamingPolicy: ...
        @property
        def securityPolicy(self) -> VmwareDistributedVirtualSwitch.SecurityPolicy: ...
        @property
        def ipfixEnabled(self) -> vim.BoolPolicy: ...
        @property
        def txUplink(self) -> vim.BoolPolicy: ...
        @property
        def lacpPolicy(self) -> VmwareDistributedVirtualSwitch.UplinkLacpPolicy: ...
        @property
        def macManagementPolicy(self) -> VmwareDistributedVirtualSwitch.MacManagementPolicy: ...
        @property
        def VNI(self) -> vim.IntPolicy: ...


    class VspanConfigSpec(vmodl.DynamicData):
        @property
        def vspanSession(self) -> VmwareDistributedVirtualSwitch.VspanSession: ...
        @property
        def operation(self) -> str: ...


    class VspanFeatureCapability(vmodl.DynamicData):
        @property
        def mixedDestSupported(self) -> bool: ...
        @property
        def dvportSupported(self) -> bool: ...
        @property
        def remoteSourceSupported(self) -> bool: ...
        @property
        def remoteDestSupported(self) -> bool: ...
        @property
        def encapRemoteSourceSupported(self) -> bool: ...
        @property
        def erspanProtocolSupported(self) -> bool: ...
        @property
        def mirrorNetstackSupported(self) -> bool: ...


    class VspanPorts(vmodl.DynamicData):
        @property
        def portKey(self) -> List[str]: ...
        @property
        def uplinkPortName(self) -> List[str]: ...
        @property
        def wildcardPortConnecteeType(self) -> List[str]: ...
        @property
        def vlans(self) -> List[int]: ...
        @property
        def ipAddress(self) -> List[str]: ...


    class VspanSession(vmodl.DynamicData):
        @property
        def key(self) -> str: ...
        @property
        def name(self) -> str: ...
        @property
        def description(self) -> str: ...
        @property
        def enabled(self) -> bool: ...
        @property
        def sourcePortTransmitted(self) -> VmwareDistributedVirtualSwitch.VspanPorts: ...
        @property
        def sourcePortReceived(self) -> VmwareDistributedVirtualSwitch.VspanPorts: ...
        @property
        def destinationPort(self) -> VmwareDistributedVirtualSwitch.VspanPorts: ...
        @property
        def encapsulationVlanId(self) -> int: ...
        @property
        def stripOriginalVlan(self) -> bool: ...
        @property
        def mirroredPacketLength(self) -> int: ...
        @property
        def normalTrafficAllowed(self) -> bool: ...
        @property
        def sessionType(self) -> str: ...
        @property
        def samplingRate(self) -> int: ...
        @property
        def encapType(self) -> str: ...
        @property
        def erspanId(self) -> int: ...
        @property
        def erspanCOS(self) -> int: ...
        @property
        def erspanGraNanosec(self) -> bool: ...
        @property
        def netstack(self) -> str: ...


    class LacpApiVersion(Enum):
        singleLag = "singlelag"
        multipleLag = "multiplelag"


    class LacpLoadBalanceAlgorithm(Enum):
        srcMac = "srcmac"
        destMac = "destmac"
        srcDestMac = "srcdestmac"
        destIpVlan = "destipvlan"
        srcIpVlan = "srcipvlan"
        srcDestIpVlan = "srcdestipvlan"
        destTcpUdpPort = "desttcpudpport"
        srcTcpUdpPort = "srctcpudpport"
        srcDestTcpUdpPort = "srcdesttcpudpport"
        destIpTcpUdpPort = "destiptcpudpport"
        srcIpTcpUdpPort = "srciptcpudpport"
        srcDestIpTcpUdpPort = "srcdestiptcpudpport"
        destIpTcpUdpPortVlan = "destiptcpudpportvlan"
        srcIpTcpUdpPortVlan = "srciptcpudpportvlan"
        srcDestIpTcpUdpPortVlan = "srcdestiptcpudpportvlan"
        destIp = "destip"
        srcIp = "srcip"
        srcDestIp = "srcdestip"
        vlan = "vlan"
        srcPortId = "srcportid"


    class MacLimitPolicyType(Enum):
        allow = "allow"
        drop = "drop"


    class MulticastFilteringMode(Enum):
        legacyFiltering = "legacyfiltering"
        snooping = "snooping"


    class PvlanPortType(Enum):
        promiscuous = "promiscuous"
        isolated = "isolated"
        community = "community"


    class TeamingMatchStatus(Enum):
        iphashMatch = "iphashmatch"
        nonIphashMatch = "noniphashmatch"
        iphashMismatch = "iphashmismatch"
        nonIphashMismatch = "noniphashmismatch"


    class UplinkLacpMode(Enum):
        active = "active"
        passive = "passive"


    class UplinkLacpTimeoutMode(Enum):
        fast = "fast"
        slow = "slow"


    class VspanSessionEncapType(Enum):
        gre = "gre"
        erspan2 = "erspan2"
        erspan3 = "erspan3"


    class VspanSessionType(Enum):
        mixedDestMirror = "mixeddestmirror"
        dvPortMirror = "dvportmirror"
        remoteMirrorSource = "remotemirrorsource"
        remoteMirrorDest = "remotemirrordest"
        encapsulatedRemoteMirrorSource = "encapsulatedremotemirrorsource"


class DistributedVirtualPort(vmodl.DynamicData):
    @property
    def key(self) -> str: ...
    @property
    def config(self) -> DistributedVirtualPort.ConfigInfo: ...
    @property
    def dvsUuid(self) -> str: ...
    @property
    def portgroupKey(self) -> str: ...
    @property
    def proxyHost(self) -> vim.HostSystem: ...
    @property
    def connectee(self) -> PortConnectee: ...
    @property
    def conflict(self) -> bool: ...
    @property
    def conflictPortKey(self) -> str: ...
    @property
    def state(self) -> DistributedVirtualPort.State: ...
    @property
    def connectionCookie(self) -> int: ...
    @property
    def lastStatusChange(self) -> datetime: ...
    @property
    def hostLocalPort(self) -> bool: ...
    @property
    def externalId(self) -> str: ...
    @property
    def segmentPortId(self) -> str: ...


    class ConfigInfo(vmodl.DynamicData):
        @property
        def name(self) -> str: ...
        @property
        def scope(self) -> List[vim.ManagedEntity]: ...
        @property
        def description(self) -> str: ...
        @property
        def setting(self) -> DistributedVirtualPort.Setting: ...
        @property
        def configVersion(self) -> str: ...


    class ConfigSpec(vmodl.DynamicData):
        @property
        def operation(self) -> str: ...
        @property
        def key(self) -> str: ...
        @property
        def name(self) -> str: ...
        @property
        def scope(self) -> List[vim.ManagedEntity]: ...
        @property
        def description(self) -> str: ...
        @property
        def setting(self) -> DistributedVirtualPort.Setting: ...
        @property
        def configVersion(self) -> str: ...


    class FilterConfig(vim.InheritablePolicy):
        @property
        def key(self) -> str: ...
        @property
        def agentName(self) -> str: ...
        @property
        def slotNumber(self) -> str: ...
        @property
        def parameters(self) -> DistributedVirtualPort.FilterParameter: ...
        @property
        def onFailure(self) -> str: ...


    class FilterConfigSpec(DistributedVirtualPort.FilterConfig):
        @property
        def operation(self) -> str: ...


    class FilterParameter(vmodl.DynamicData):
        @property
        def parameters(self) -> List[str]: ...


    class FilterPolicy(vim.InheritablePolicy):
        @property
        def filterConfig(self) -> List[DistributedVirtualPort.FilterConfig]: ...


    class HostLocalPortInfo(vmodl.DynamicData):
        @property
        def switchUuid(self) -> str: ...
        @property
        def portKey(self) -> str: ...
        @property
        def setting(self) -> DistributedVirtualPort.Setting: ...
        @property
        def vnic(self) -> str: ...


    class RuntimeInfo(vmodl.DynamicData):
        @property
        def linkUp(self) -> bool: ...
        @property
        def blocked(self) -> bool: ...
        @property
        def vlanIds(self) -> List[vim.NumericRange]: ...
        @property
        def trunkingMode(self) -> bool: ...
        @property
        def mtu(self) -> int: ...
        @property
        def linkPeer(self) -> str: ...
        @property
        def macAddress(self) -> str: ...
        @property
        def statusDetail(self) -> str: ...
        @property
        def vmDirectPathGen2Active(self) -> bool: ...
        @property
        def vmDirectPathGen2InactiveReasonNetwork(self) -> List[str]: ...
        @property
        def vmDirectPathGen2InactiveReasonOther(self) -> List[str]: ...
        @property
        def vmDirectPathGen2InactiveReasonExtended(self) -> str: ...


        class VmDirectPathGen2InactiveReasonNetwork(Enum):
            portNptIncompatibleDvs = "portnptincompatibledvs"
            portNptNoCompatibleNics = "portnptnocompatiblenics"
            portNptNoVirtualFunctionsAvailable = "portnptnovirtualfunctionsavailable"
            portNptDisabledForPort = "portnptdisabledforport"


        class VmDirectPathGen2InactiveReasonOther(Enum):
            portNptIncompatibleHost = "portnptincompatiblehost"
            portNptIncompatibleConnectee = "portnptincompatibleconnectee"


    class Setting(vmodl.DynamicData):
        @property
        def blocked(self) -> vim.BoolPolicy: ...
        @property
        def vmDirectPathGen2Allowed(self) -> vim.BoolPolicy: ...
        @property
        def inShapingPolicy(self) -> DistributedVirtualPort.TrafficShapingPolicy: ...
        @property
        def outShapingPolicy(self) -> DistributedVirtualPort.TrafficShapingPolicy: ...
        @property
        def vendorSpecificConfig(self) -> DistributedVirtualPort.VendorSpecificConfig: ...
        @property
        def networkResourcePoolKey(self) -> vim.StringPolicy: ...
        @property
        def filterPolicy(self) -> DistributedVirtualPort.FilterPolicy: ...


    class State(vmodl.DynamicData):
        @property
        def runtimeInfo(self) -> DistributedVirtualPort.RuntimeInfo: ...
        @property
        def stats(self) -> PortStatistics: ...
        @property
        def vendorSpecificState(self) -> List[KeyedOpaqueBlob]: ...


    class TrafficFilterConfig(DistributedVirtualPort.FilterConfig):
        @property
        def trafficRuleset(self) -> TrafficRuleset: ...


    class TrafficFilterConfigSpec(DistributedVirtualPort.TrafficFilterConfig):
        @property
        def operation(self) -> str: ...


    class TrafficShapingPolicy(vim.InheritablePolicy):
        @property
        def enabled(self) -> vim.BoolPolicy: ...
        @property
        def averageBandwidth(self) -> vim.LongPolicy: ...
        @property
        def peakBandwidth(self) -> vim.LongPolicy: ...
        @property
        def burstSize(self) -> vim.LongPolicy: ...


    class VendorSpecificConfig(vim.InheritablePolicy):
        @property
        def keyValue(self) -> List[KeyedOpaqueBlob]: ...


    class FilterOnFailure(Enum):
        failOpen = "failopen"
        failClosed = "failclosed"


class DistributedVirtualPortgroupInfo(vmodl.DynamicData):
    @property
    def switchName(self) -> str: ...
    @property
    def switchUuid(self) -> str: ...
    @property
    def portgroupName(self) -> str: ...
    @property
    def portgroupKey(self) -> str: ...
    @property
    def portgroupType(self) -> str: ...
    @property
    def uplinkPortgroup(self) -> bool: ...
    @property
    def portgroup(self) -> DistributedVirtualPortgroup: ...
    @property
    def networkReservationSupported(self) -> bool: ...
    @property
    def backingType(self) -> str: ...
    @property
    def logicalSwitchUuid(self) -> str: ...
    @property
    def segmentId(self) -> str: ...


class DistributedVirtualPortgroupSelection(vim.SelectionSet):
    @property
    def dvsUuid(self) -> str: ...
    @property
    def portgroupKey(self) -> List[str]: ...


class DistributedVirtualSwitchInfo(vmodl.DynamicData):
    @property
    def switchName(self) -> str: ...
    @property
    def switchUuid(self) -> str: ...
    @property
    def distributedVirtualSwitch(self) -> vim.DistributedVirtualSwitch: ...
    @property
    def networkReservationSupported(self) -> bool: ...


class DistributedVirtualSwitchSelection(vim.SelectionSet):
    @property
    def dvsUuid(self) -> str: ...


class EntityBackup(vmodl.DynamicData):


    class Config(vmodl.DynamicData):
        @property
        def entityType(self) -> str: ...
        @property
        def configBlob(self) -> binary: ...
        @property
        def key(self) -> str: ...
        @property
        def name(self) -> str: ...
        @property
        def container(self) -> vim.ManagedEntity: ...
        @property
        def configVersion(self) -> str: ...


    class EntityType(Enum):
        distributedVirtualSwitch = "distributedvirtualswitch"
        distributedVirtualPortgroup = "distributedvirtualportgroup"


    class ImportType(Enum):
        createEntityWithNewIdentifier = "createentitywithnewidentifier"
        createEntityWithOriginalIdentifier = "createentitywithoriginalidentifier"
        applyToEntitySpecified = "applytoentityspecified"


class HostMember(vmodl.DynamicData):
    @property
    def runtimeState(self) -> HostMember.RuntimeState: ...
    @property
    def config(self) -> HostMember.ConfigInfo: ...
    @property
    def productInfo(self) -> ProductSpec: ...
    @property
    def uplinkPortKey(self) -> List[str]: ...
    @property
    def status(self) -> str: ...
    @property
    def statusDetail(self) -> str: ...


    class Backing(vmodl.DynamicData): ...


    class HealthCheckResult(vmodl.DynamicData):
        @property
        def summary(self) -> str: ...


    class PnicBacking(HostMember.Backing):
        @property
        def pnicSpec(self) -> List[HostMember.PnicSpec]: ...


    class PnicSpec(vmodl.DynamicData):
        @property
        def pnicDevice(self) -> str: ...
        @property
        def uplinkPortKey(self) -> str: ...
        @property
        def uplinkPortgroupKey(self) -> str: ...
        @property
        def connectionCookie(self) -> int: ...


    class RuntimeState(vmodl.DynamicData):
        @property
        def currentMaxProxySwitchPorts(self) -> int: ...


    class TransportZoneInfo(vmodl.DynamicData):
        @property
        def uuid(self) -> str: ...
        @property
        def type(self) -> str: ...


    class UplinkHealthCheckResult(HostMember.HealthCheckResult):
        @property
        def uplinkPortKey(self) -> str: ...


    class HostComponentState(Enum):
        up = "up"
        pending = "pending"
        outOfSync = "outofsync"
        warning = "warning"
        disconnected = "disconnected"
        down = "down"


    class TransportZoneType(Enum):
        vlan = "vlan"
        overlay = "overlay"


class HostProductSpec(vmodl.DynamicData):
    @property
    def productLineId(self) -> str: ...
    @property
    def version(self) -> str: ...


class KeyedOpaqueBlob(vmodl.DynamicData):
    @property
    def key(self) -> str: ...
    @property
    def opaqueData(self) -> str: ...


class NetworkOffloadSpec(vmodl.DynamicData):
    @property
    def id(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def types(self) -> List[str]: ...


class NetworkResourcePool(vmodl.DynamicData):
    @property
    def key(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def description(self) -> str: ...
    @property
    def configVersion(self) -> str: ...
    @property
    def allocationInfo(self) -> NetworkResourcePool.AllocationInfo: ...


    class AllocationInfo(vmodl.DynamicData):
        @property
        def limit(self) -> long: ...
        @property
        def shares(self) -> vim.SharesInfo: ...
        @property
        def priorityTag(self) -> int: ...


class PortConnectee(vmodl.DynamicData):
    @property
    def connectedEntity(self) -> vim.ManagedEntity: ...
    @property
    def nicKey(self) -> str: ...
    @property
    def type(self) -> str: ...
    @property
    def addressHint(self) -> str: ...


    class ConnecteeType(Enum):
        pnic = "pnic"
        vmVnic = "vmvnic"
        hostConsoleVnic = "hostconsolevnic"
        hostVmkVnic = "hostvmkvnic"
        systemCrxVnic = "systemcrxvnic"


class PortConnection(vmodl.DynamicData):
    @property
    def switchUuid(self) -> str: ...
    @property
    def portgroupKey(self) -> str: ...
    @property
    def portKey(self) -> str: ...
    @property
    def connectionCookie(self) -> int: ...


class PortCriteria(vmodl.DynamicData):
    @property
    def connected(self) -> bool: ...
    @property
    def active(self) -> bool: ...
    @property
    def uplinkPort(self) -> bool: ...
    @property
    def nsxPort(self) -> bool: ...
    @property
    def scope(self) -> vim.ManagedEntity: ...
    @property
    def portgroupKey(self) -> List[str]: ...
    @property
    def inside(self) -> bool: ...
    @property
    def portKey(self) -> List[str]: ...
    @property
    def host(self) -> List[vim.HostSystem]: ...


class PortStatistics(vmodl.DynamicData):
    @property
    def packetsInMulticast(self) -> long: ...
    @property
    def packetsOutMulticast(self) -> long: ...
    @property
    def bytesInMulticast(self) -> long: ...
    @property
    def bytesOutMulticast(self) -> long: ...
    @property
    def packetsInUnicast(self) -> long: ...
    @property
    def packetsOutUnicast(self) -> long: ...
    @property
    def bytesInUnicast(self) -> long: ...
    @property
    def bytesOutUnicast(self) -> long: ...
    @property
    def packetsInBroadcast(self) -> long: ...
    @property
    def packetsOutBroadcast(self) -> long: ...
    @property
    def bytesInBroadcast(self) -> long: ...
    @property
    def bytesOutBroadcast(self) -> long: ...
    @property
    def packetsInDropped(self) -> long: ...
    @property
    def packetsOutDropped(self) -> long: ...
    @property
    def packetsInException(self) -> long: ...
    @property
    def packetsOutException(self) -> long: ...
    @property
    def bytesInFromPnic(self) -> long: ...
    @property
    def bytesOutToPnic(self) -> long: ...


class ProductSpec(vmodl.DynamicData):
    @property
    def name(self) -> str: ...
    @property
    def vendor(self) -> str: ...
    @property
    def version(self) -> str: ...
    @property
    def build(self) -> str: ...
    @property
    def forwardingClass(self) -> str: ...
    @property
    def bundleId(self) -> str: ...
    @property
    def bundleUrl(self) -> str: ...


class TrafficRule(vmodl.DynamicData):
    @property
    def key(self) -> str: ...
    @property
    def description(self) -> str: ...
    @property
    def sequence(self) -> int: ...
    @property
    def qualifier(self) -> List[TrafficRule.Qualifier]: ...
    @property
    def action(self) -> TrafficRule.Action: ...
    @property
    def direction(self) -> str: ...


    class AcceptAction(TrafficRule.Action): ...


    class Action(vmodl.DynamicData): ...


    class CopyAction(TrafficRule.Action): ...


    class DropAction(TrafficRule.Action): ...


    class GreAction(TrafficRule.Action):
        @property
        def encapsulationIp(self) -> vim.SingleIp: ...


    class IpPort(vim.NegatableExpression): ...


    class IpPortRange(TrafficRule.IpPort):
        @property
        def startPortNumber(self) -> int: ...
        @property
        def endPortNumber(self) -> int: ...


    class IpQualifier(TrafficRule.Qualifier):
        @property
        def sourceAddress(self) -> vim.IpAddress: ...
        @property
        def destinationAddress(self) -> vim.IpAddress: ...
        @property
        def protocol(self) -> vim.IntExpression: ...
        @property
        def sourceIpPort(self) -> TrafficRule.IpPort: ...
        @property
        def destinationIpPort(self) -> TrafficRule.IpPort: ...
        @property
        def tcpFlags(self) -> vim.IntExpression: ...


    class LogAction(TrafficRule.Action): ...


    class MacQualifier(TrafficRule.Qualifier):
        @property
        def sourceAddress(self) -> vim.MacAddress: ...
        @property
        def destinationAddress(self) -> vim.MacAddress: ...
        @property
        def protocol(self) -> vim.IntExpression: ...
        @property
        def vlanId(self) -> vim.IntExpression: ...


    class MacRewriteAction(TrafficRule.Action):
        @property
        def rewriteMac(self) -> str: ...


    class PuntAction(TrafficRule.Action): ...


    class Qualifier(vmodl.DynamicData):
        @property
        def key(self) -> str: ...


    class RateLimitAction(TrafficRule.Action):
        @property
        def packetsPerSecond(self) -> int: ...


    class SingleIpPort(TrafficRule.IpPort):
        @property
        def portNumber(self) -> int: ...


    class SystemTrafficQualifier(TrafficRule.Qualifier):
        @property
        def typeOfSystemTraffic(self) -> vim.StringExpression: ...


    class UpdateTagAction(TrafficRule.Action):
        @property
        def qosTag(self) -> int: ...
        @property
        def dscpTag(self) -> int: ...


    class RuleDirectionType(Enum):
        incomingPackets = "incomingpackets"
        outgoingPackets = "outgoingpackets"
        both = "both"


class TrafficRuleset(vmodl.DynamicData):
    @property
    def key(self) -> str: ...
    @property
    def enabled(self) -> bool: ...
    @property
    def precedence(self) -> int: ...
    @property
    def rules(self) -> List[TrafficRule]: ...


class VmVnicNetworkResourcePool(vmodl.DynamicData):
    @property
    def key(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def description(self) -> str: ...
    @property
    def configVersion(self) -> str: ...
    @property
    def allocationInfo(self) -> VmVnicNetworkResourcePool.ResourceAllocation: ...


    class ResourceAllocation(vmodl.DynamicData):
        @property
        def reservationQuota(self) -> long: ...


    class VnicAllocatedResource(vmodl.DynamicData):
        @property
        def vm(self) -> vim.VirtualMachine: ...
        @property
        def vnicKey(self) -> str: ...
        @property
        def reservation(self) -> long: ...


class SwitchMode(vim.version.v8_0_0_1): ...


class SwitchMode(vim.version.v8_0_0_1): ...