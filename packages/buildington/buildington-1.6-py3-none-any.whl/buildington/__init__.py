GETMET = 0
POSTMET = 1
GETONLY = DEFAULT = [GETMET]
POSTONLY = [POSTMET]
ALLMETS = GETONLY + POSTONLY
PAGES = tuple()
FILES = tuple()
webName = "Buildington"

class Para:
	def __init__(self, innerHTML, props=None):
		self.innerHTML = innerHTML
		self.props = props
		if not isinstance(self.props, dict):
			self.props = {}
		elif type(self.props) != dict:
			self.props = dict(self.props)
		self.html = "p"

	def __str__(self):
		def escapeHTML(txt):
			res = ""
			for char in txt:
				res += "&#" + str(ord(char)) + ";"
			return res
        
		return "<" + self.html + ">" + escapeHTML(self.innerHTML) + "</" + self.html + ">"

class Header(Para):
	def __init__(self, innerHTML, props=None):
		super().__init__(innerHTML, props)
		self.html = "h" + str(int(self.props["size"]))

def page(route, opts=None):
	if opts is None:
		opts = {}
	opts = dict(opts)
	if "met" not in opts:
		opts["met"] = ALLMETS
	def decor(func):
		if not route.startswith("/"):
			raise ValueError(repr(route) + " should begin with " + repr("/"))
		PAGES = list(globals()["PAGES"])
		PAGES.append((route, func, opts))
		globals()["PAGES"] = tuple(PAGES)
		del locals()["PAGES"]
		def wrap(*args, **kwargs):
			res = func(*args, **kwargs)
			if not isinstance(res, tuple):
				raise ValueError(str(func).split(" ")[1] + " did not return a tuple")
			for elem in res:
				if not isinstance(elem, Para):
					raise ValueError("One of " + str(func).split(" ")[1] + "'s elements was not a valid " + __name__)
			return res
		return wrap
	return decor

def addFile(file, asType="file"):
	if asType not in ["file", "script", "style"]:
		raise TypeError("Invalid file type '" + str(asType) + "'")
	FILES = list(globals()["FILES"])
	FILES.append((file, asType))
	globals()["FILES"] = tuple(FILES)
	PAGES = list(globals()["PAGES"])
	def returnResp():
		import flask
		import os
		return flask.send_from_directory(os.getcwd(), file)
	PAGES.append(("/" + file, returnResp, {"met": GETONLY}))
	globals()["PAGES"] = tuple(PAGES)
	del locals()["PAGES"]

def start(host, port):
	import flask, threading, inspect
	targetGlob = inspect.currentframe().f_back.f_globals
	for var in targetGlob.values():
		if isinstance(var, flask.Flask):
			app = var
	if "app" not in locals():
		app = flask.Flask(__name__) # The module name will fit :)
	@app.route("/<path:path>", methods=["GET", "POST"])
	@app.route("/", methods=["GET", "POST"])
	def endpnt(path=None):
		if path is None:
			path = ""
		path = "/" + path
		foundEndpnt = False
		count = 0
		while count != len(globals()["PAGES"]):
			endpnt = globals()["PAGES"][count]
			if endpnt[0] == path:
				foundEndpnt = True
				break
			count += 1
		if foundEndpnt == False:
			return flask.abort(404) # Page not found!!1
		endpntMets = []
		count = 0
		for met in endpnt[2]["met"]:
			endpntMets.append("GET" if met == GETMET else ("POST" if met == POSTMET else None))
			count += 1
		if flask.request.method.upper() not in endpntMets:
			return flask.abort(405)
		del locals()["endpntMets"]
		bdRes = endpnt[1]()
		def escapeHTML(txt):
			res = ""
			for char in txt:
				res += "&#" + str(ord(char)) + ";"
			return res
		count = 0
		if not isinstance(bdRes, tuple):
			return bdRes
		bdRes = list(bdRes)
		for elem in bdRes:
			if isinstance(elem, str):
				elem = escapeHTML(elem)
			elem = str(elem)
			bdRes[count] = elem
			count += 1
		scripts = [""]
		styles = [""]
		count = 0
		while count != len(FILES):
			if FILES[count][1] == "script":
				scripts[-1] = "<script src=\"/" + FILES[count][0] + "\"></script>"
				scripts.append("")
			elif FILES[count][1] == "style":
				styles[-1] = "<link href=\"/" + FILES[count][0] + "\" rel=\"stylesheet\">"
				styles.append("")
			count += 1
		scripts = "\n\t\t".join(scripts)
		styles = "\n\t\t".join(styles)
		htmlRes = "<!-- Page generated by Buildington -->\n<!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"utf-8\">\n\t\t<meta name=\"viewport\" content=\"width=device-width\">\n\t\t" + styles + "<title>" + webName + "</title>\n\t</head>\n\t<body>\n\t"
		for line in bdRes:
			htmlRes += "\t" + line + "\n\t"
		if scripts != "":
			htmlRes += "\t" + scripts[:-1]
		htmlRes += "</body>\n</html>"
		htmlRes = htmlRes.replace("<body>\n\t</body>", "<body></body>")
		return htmlRes
	app.run(host, port)