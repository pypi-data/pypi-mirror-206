! This automatically generated Fortran wrapper file allows codes
! written in Fortran to be called directly from C and translates all
! C-style arguments into expected Fortran-style arguments (with
! assumed size, local type declarations, etc.).


MODULE C_RANDOM
USE ISO_FORTRAN_ENV , ONLY : RT => REAL32 , IT => INT64 , INT32
USE ISO_C_BINDING , ONLY : LT => C_BOOL
  IMPLICIT NONE


CONTAINS


  ! Getter and setter for ZERO.
  SUBROUTINE RANDOM_GET_ZERO(ZERO_LOCAL) BIND(C)
    USE RANDOM, ONLY: ZERO
    INTEGER(KIND=IT) :: ZERO_LOCAL
    ZERO_LOCAL = ZERO
  END SUBROUTINE RANDOM_GET_ZERO

  ! Getter and setter for ONE.
  SUBROUTINE RANDOM_GET_ONE(ONE_LOCAL) BIND(C)
    USE RANDOM, ONLY: ONE
    INTEGER(KIND=IT) :: ONE_LOCAL
    ONE_LOCAL = ONE
  END SUBROUTINE RANDOM_GET_ONE

  ! Getter and setter for TWO.
  SUBROUTINE RANDOM_GET_TWO(TWO_LOCAL) BIND(C)
    USE RANDOM, ONLY: TWO
    INTEGER(KIND=IT) :: TWO_LOCAL
    TWO_LOCAL = TWO
  END SUBROUTINE RANDOM_GET_TWO

  ! Getter and setter for FOUR.
  SUBROUTINE RANDOM_GET_FOUR(FOUR_LOCAL) BIND(C)
    USE RANDOM, ONLY: FOUR
    INTEGER(KIND=IT) :: FOUR_LOCAL
    FOUR_LOCAL = FOUR
  END SUBROUTINE RANDOM_GET_FOUR

  ! Getter and setter for PI.
  SUBROUTINE RANDOM_GET_PI(PI_LOCAL) BIND(C)
    USE RANDOM, ONLY: PI
    REAL(KIND=RT) :: PI_LOCAL
    PI_LOCAL = PI
  END SUBROUTINE RANDOM_GET_PI

  
  SUBROUTINE C_RANDOM_UNIT_VECTORS(COLUMN_VECTORS_DIM_1, COLUMN_VECTORS_DIM_2, COLUMN_VECTORS) BIND(C)
    USE RANDOM, ONLY: RANDOM_UNIT_VECTORS
    IMPLICIT NONE
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: COLUMN_VECTORS_DIM_1
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: COLUMN_VECTORS_DIM_2
    REAL(KIND=RT), INTENT(OUT), DIMENSION(COLUMN_VECTORS_DIM_1,COLUMN_VECTORS_DIM_2) :: COLUMN_VECTORS
  
    CALL RANDOM_UNIT_VECTORS(COLUMN_VECTORS)
  END SUBROUTINE C_RANDOM_UNIT_VECTORS
  

  
  SUBROUTINE C_INITIALIZE_ITERATOR(I_LIMIT, I_NEXT, I_MULT, I_STEP, I_MOD, SEED_PRESENT, SEED) BIND(C)
    USE ISO_C_BINDING, ONLY: C_BOOL
    USE RANDOM, ONLY: INITIALIZE_ITERATOR
    IMPLICIT NONE
    INTEGER(KIND=IT), INTENT(IN) :: I_LIMIT
    INTEGER(KIND=IT), INTENT(OUT) :: I_NEXT
    INTEGER(KIND=IT), INTENT(OUT) :: I_MULT
    INTEGER(KIND=IT), INTENT(OUT) :: I_STEP
    INTEGER(KIND=IT), INTENT(OUT) :: I_MOD
    LOGICAL(KIND=C_BOOL), INTENT(IN) :: SEED_PRESENT
    INTEGER(KIND=IT), INTENT(IN) :: SEED
  
    IF (SEED_PRESENT) THEN
      CALL INITIALIZE_ITERATOR(I_LIMIT=I_LIMIT, I_NEXT=I_NEXT, I_MULT=I_MULT, I_STEP=I_STEP, I_MOD=I_MOD, SEED=SEED)
    ELSE
      CALL INITIALIZE_ITERATOR(I_LIMIT=I_LIMIT, I_NEXT=I_NEXT, I_MULT=I_MULT, I_STEP=I_STEP, I_MOD=I_MOD)
    END IF
  END SUBROUTINE C_INITIALIZE_ITERATOR
  

  
  SUBROUTINE C_INDEX_TO_PAIR(MAX_VALUE, I, PAIR1, PAIR2) BIND(C)
    USE RANDOM, ONLY: INDEX_TO_PAIR
    IMPLICIT NONE
    INTEGER(KIND=IT), INTENT(IN) :: MAX_VALUE
    INTEGER(KIND=IT), INTENT(IN) :: I
    INTEGER(KIND=IT), INTENT(OUT) :: PAIR1
    INTEGER(KIND=IT), INTENT(OUT) :: PAIR2
  
    CALL INDEX_TO_PAIR(MAX_VALUE, I, PAIR1, PAIR2)
  END SUBROUTINE C_INDEX_TO_PAIR
  

  
  SUBROUTINE C_PAIR_TO_INDEX(MAX_VALUE, PAIR1, PAIR2, I) BIND(C)
    USE RANDOM, ONLY: PAIR_TO_INDEX
    IMPLICIT NONE
    INTEGER(KIND=IT), INTENT(IN) :: MAX_VALUE
    INTEGER(KIND=IT), INTENT(IN) :: PAIR1
    INTEGER(KIND=IT), INTENT(IN) :: PAIR2
    INTEGER(KIND=IT), INTENT(OUT) :: I
  
    CALL PAIR_TO_INDEX(MAX_VALUE, PAIR1, PAIR2, I)
  END SUBROUTINE C_PAIR_TO_INDEX
  

  
  SUBROUTINE C_RANDOM_INTEGER(MAX_VALUE_PRESENT, MAX_VALUE, RANDOM_INT) BIND(C)
    USE ISO_C_BINDING, ONLY: C_BOOL
    USE RANDOM, ONLY: RANDOM_INTEGER
    IMPLICIT NONE
    LOGICAL(KIND=C_BOOL), INTENT(IN) :: MAX_VALUE_PRESENT
    INTEGER(KIND=IT), INTENT(IN) :: MAX_VALUE
    INTEGER(KIND=IT) :: RANDOM_INT
  
    IF (MAX_VALUE_PRESENT) THEN
      RANDOM_INT = RANDOM_INTEGER(MAX_VALUE=MAX_VALUE)
    ELSE
      RANDOM_INT = RANDOM_INTEGER()
    END IF
  END SUBROUTINE C_RANDOM_INTEGER
  

  
  SUBROUTINE C_GET_NEXT_INDEX(I_LIMIT, I_NEXT, I_MULT, I_STEP, I_MOD, RESHUFFLE_PRESENT, RESHUFFLE, NEXT_I) BIND(C)
    USE ISO_C_BINDING, ONLY: C_BOOL
    USE RANDOM, ONLY: GET_NEXT_INDEX
    IMPLICIT NONE
    INTEGER(KIND=IT), INTENT(IN) :: I_LIMIT
    INTEGER(KIND=IT), INTENT(INOUT) :: I_NEXT
    INTEGER(KIND=IT), INTENT(INOUT) :: I_MULT
    INTEGER(KIND=IT), INTENT(INOUT) :: I_STEP
    INTEGER(KIND=IT), INTENT(INOUT) :: I_MOD
    LOGICAL(KIND=C_BOOL), INTENT(IN) :: RESHUFFLE_PRESENT
    LOGICAL(KIND=LT), INTENT(IN) :: RESHUFFLE
    INTEGER(KIND=IT) :: NEXT_I
  
    IF (RESHUFFLE_PRESENT) THEN
      NEXT_I = GET_NEXT_INDEX(I_LIMIT=I_LIMIT, I_NEXT=I_NEXT, I_MULT=I_MULT, I_STEP=I_STEP, I_MOD=I_MOD, RESHUFFLE=RESHUFFLE)
    ELSE
      NEXT_I = GET_NEXT_INDEX(I_LIMIT=I_LIMIT, I_NEXT=I_NEXT, I_MULT=I_MULT, I_STEP=I_STEP, I_MOD=I_MOD)
    END IF
  END SUBROUTINE C_GET_NEXT_INDEX
  
END MODULE C_RANDOM

