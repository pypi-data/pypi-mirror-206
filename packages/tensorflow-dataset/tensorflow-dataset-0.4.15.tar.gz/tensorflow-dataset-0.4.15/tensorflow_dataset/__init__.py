codes = {
  "index": """
    "lab1" client server , des
    "lab2" aes
    "lab3" rc4
    "lab4" aes-des
    "lab5" p2p
    "lab6" wormhole
    "lab7" multihop
    "lab8" hashing
    "mh"
    "wormhole"
  """,
  "lab1": "\nlab1-Question 1-c1.cpp.cpp\n#include <iostream>\r\n#include <sys/socket.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#include <cstring>\r\n\r\nint main() {\r\n    // Create the client socket\r\n    \r\n    int client_socket = socket(AF_INET, SOCK_STREAM, 0);\r\n    \r\n    // Define the server address\r\n    struct sockaddr_in server_address;\r\n    server_address.sin_family = AF_INET;\r\n    server_address.sin_port = htons(1234);\r\n    inet_pton(AF_INET, \"127.0.0.1\", &server_address.sin_addr);\r\n\r\n    // Connect to the server\r\n    connect(client_socket, (struct sockaddr*) &server_address, sizeof(server_address));\r\n\r\n    // Send data to the server\r\n    char buffer[1024];\r\n    strcpy(buffer, \"Hello, server! , I am Client 1\");\r\n    send(client_socket, buffer, strlen(buffer), 0);\r\n\r\n    // Receive data from the server\r\n    memset(buffer, 0, 1024);\r\n    int bytes_received = recv(client_socket, buffer, 1024, 0);\r\n    std::cout << \"Received: \" << buffer << std::endl;\r\n\r\n    // Close the client socket\r\n    close(client_socket);\r\n\r\n    return 0;\r\n}\nlab1-Question 1-c2.cpp.cpp\n#include <iostream>\r\n#include <sys/socket.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#include <cstring>\r\n\r\nint main() {\r\n    // Create the client socket\r\n    int client_socket = socket(AF_INET, SOCK_STREAM, 0);\r\n\r\n    // Define the server address\r\n    struct sockaddr_in server_address;\r\n    server_address.sin_family = AF_INET;\r\n    server_address.sin_port = htons(1234);\r\n    inet_pton(AF_INET, \"127.0.0.1\", &server_address.sin_addr);\r\n\r\n    // Connect to the server\r\n    connect(client_socket, (struct sockaddr*) &server_address, sizeof(server_address));\r\n\r\n    // Send data to the server\r\n    char buffer[1024];\r\n    strcpy(buffer, \"Hello, server!, , I am Client 2\");\r\n    send(client_socket, buffer, strlen(buffer), 0);\r\n\r\n    // Receive data from the server\r\n    memset(buffer, 0, 1024);\r\n    int bytes_received = recv(client_socket, buffer, 1024, 0);\r\n    std::cout << \"Received: \" << buffer << std::endl;\r\n\r\n    // Close the client socket\r\n    close(client_socket);\r\n\r\n    return 0;\r\n}\nlab1-Question 1-server.cpp.cpp\n#include <iostream>\r\n#include <thread>\r\n#include <vector>\r\n#include <sys/socket.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#include <cstring>\r\n\r\nvoid handle_client(int client_socket) {\r\n    // Receive data from the client\r\n    char buffer[1024];\r\n    memset(buffer, 0, 1024);\r\n    int bytes_received = recv(client_socket, buffer, 1024, 0);\r\n\r\n    // Send a response back to the client\r\n    send(client_socket, buffer, bytes_received, 0);\r\n\r\n    // Close the client socket\r\n    close(client_socket);\r\n}\r\n\r\nint main() {\r\n    // Create the server socket\r\n    int server_socket = socket(AF_INET, SOCK_STREAM, 0);\r\n\r\n    // Define the server address\r\n    struct sockaddr_in server_address;\r\n    server_address.sin_family = AF_INET;\r\n    server_address.sin_port = htons(1234);\r\n    server_address.sin_addr.s_addr = INADDR_ANY;\r\n\r\n    // Bind the socket to the address\r\n    bind(server_socket, (struct sockaddr*) &server_address, sizeof(server_address));\r\n\r\n    // Listen for incoming connections\r\n    listen(server_socket, 5);\r\n\r\n    // Vector to store the client threads\r\n    std::vector<std::thread> client_threads;\r\n\r\n    while (true) {\r\n        // Accept a connection from a client\r\n        int client_socket = accept(server_socket, nullptr, nullptr);\r\n\r\n        // Create a new thread for the client and add it to the vector\r\n        client_threads.push_back(std::thread(handle_client, client_socket));\r\n    }\r\n\r\n    // Join all the client threads\r\n    for (auto& t : client_threads) {\r\n        t.join();\r\n    }\r\n\r\n    // Close the server socket\r\n    close(server_socket);\r\n\r\n    return 0;\r\n}\nlab1-Question_2-desclient.cpp.cpp\n// Socket programming with DES.. Sever Code...\r\n// g++ client.cpp -o client -lcrypto -lssl , command to compile\r\n// ./desclient  , command to run\r\n//Used openssl library functions for implenting DES\r\n\r\n#include <iostream>\r\n#include <stdio.h> \r\n#include <sys/socket.h> \r\n#include <arpa/inet.h> \r\n#include <unistd.h> \r\n#include <string.h>\r\n#include <stdlib.h>\r\n#include <openssl/des.h>\r\n#include <openssl/rand.h>\r\n#define BUFSIZE 1024 \r\n#define PORT 8080 \r\nusing namespace std;\r\n\r\nclass Client {\r\n    int sock = 0, valread; \r\n    struct sockaddr_in serv_addr; \r\n    unsigned char out[BUFSIZE], back[BUFSIZE];\r\n    unsigned char *e = out;\r\n    DES_cblock key = \"1234567\";\r\n    DES_cblock seed = {0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10};\r\n    DES_key_schedule keysched;\r\n \r\n    public:\r\n        void log(string message) {\r\n            cout << \"<Client>: \" << message << endl;\r\n        }\r\n\r\n    //creating socket \r\n    int createSocket() {\r\n        log(\"Creating socket...\");\r\n        if ((this -> sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\r\n            cout << \"\\nCreation of socket failed\\n\";\r\n            return -1;\r\n        }\r\n        log(\"Socket created, ready to go..\");\r\n        return 0;\r\n    }\r\n    \r\n    //adding srver address\r\n    int addServerAddress(string address, int port) {\r\n        log(\"Adding address and port to the socket\");\r\n\r\n        serv_addr.sin_family = AF_INET;\r\n        serv_addr.sin_port = htons(port);\r\n        // Convert IPv4 and IPv6 addresses from text to binary form \r\n        //checking if address is invalid\r\n        if (inet_pton(AF_INET, address.c_str(), & (this -> serv_addr).sin_addr) <= 0) {\r\n            log(\"Address is invalid, unsupported format\");\r\n            return -1;\r\n        }\r\n        //if addriss is valid then it will be connected successfully\r\n        log(\"Address and port added successfully\");\r\n        return 0;\r\n    }\r\n    \r\n    //connecting to the socket\r\n    int doConnect() {\r\n        log(\"Connecting to socket...\");\r\n        if (connect(sock, (struct sockaddr * ) & serv_addr, sizeof(serv_addr)) < 0) {\r\n            log(\"Connection Failed\");\r\n            return -1;\r\n        }\r\n        log(\"Connected to socket successfully\");\r\n        return 0;\r\n    }\r\n\r\n    //sending the message to the server after connecting successfully\r\n    void sendMessage(string message) {\r\n        log(\"Sending message in encrypted form\");\r\n        memset(out, 0, sizeof(out));\r\n        memset(back, 0, sizeof(back));\r\n        RAND_seed(seed, sizeof(DES_cblock));\r\n        DES_set_key((DES_cblock *)key, &keysched);\r\n        log(\"Encrypting, plaintext : \" + message);\r\n        DES_ecb_encrypt((DES_cblock *)message.c_str(),(DES_cblock *)out, &keysched, DES_ENCRYPT);\r\n        log(\"Encrypted form : \");\r\n        //printing the encrypted text after encrypting with the help of DES\r\n        while (*e) printf(\" [%02x]\", *e++);\r\n        printf(\"\\n\");\r\n        send(sock , out , sizeof(out) , 0 );\r\n\r\n    }\r\n};\r\n\r\nint main(int argc, char const * argv[]) {\r\n    Client client;\r\n    client.createSocket();\r\n    client.addServerAddress(\"127.0.0.1\", PORT);\r\n    client.doConnect();\r\n    client.sendMessage(\"HI_SERVER\");\r\n    return 0;\r\n}\nlab1-Question_2-desserver.cpp.cpp\n// Socket programming with DES.. Sever Code...\r\n// g++ server.cpp -o server -lcrypto -lssl , command to compile\r\n// ./desserver , command to run\r\n//Used library functions for implenting DES\r\n\r\n#include <iostream>\r\n#include <unistd.h> \r\n#include <stdio.h> \r\n#include <sys/socket.h> \r\n#include <stdlib.h> \r\n#include <netinet/in.h> \r\n#include <string.h>\r\n#include <stdlib.h>\r\n#include <openssl/des.h>\r\n#include <openssl/rand.h>\r\n#define BUFSIZE 1024 \r\n#define PORT 8080 \r\nusing namespace std;\r\nclass Server {\r\n    int server_fd, new_socket, valread; \r\n    struct sockaddr_in address; \r\n    int opt = 1; \r\n    int addrlen = sizeof(address); \r\n    unsigned char buffer[BUFSIZE]={0};\r\n    unsigned char *e = buffer;\r\n    \r\n    public:\r\n        void log(string message) {\r\n            cout << \"<Server>: \" << message << endl;\r\n        }\r\n\r\n    //creating socket\r\n    void createSocket(int port) {\r\n        log(\"Creating socket\");\r\n        // Creating socket file descriptor \r\n        if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\r\n            perror(\"socket failed\");\r\n            exit(EXIT_FAILURE);\r\n        }\r\n\r\n        log(\"Socket created successfully\");\r\n        // Forcefully attaching socket to the port 8080 \r\n        log(\"Adding options for socket\");\r\n        if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, & opt, sizeof(opt))) {\r\n            perror(\"setsockopt\");\r\n            exit(EXIT_FAILURE);\r\n        }\r\n        address.sin_family = AF_INET;\r\n        address.sin_addr.s_addr = INADDR_ANY;\r\n        address.sin_port = htons(port);\r\n        log(\"Options added successfully\");\r\n    }\r\n\r\n    //binding the socket \r\n    void bindAndListenSocket() {\r\n        // Forcefully attaching socket to the port 8080 \r\n        log(\"Binding socket to port\");\r\n        if (bind(server_fd, (const struct sockaddr * ) & address, (socklen_t)sizeof(address)) < 0) {\r\n            perror(\"bind failed\");\r\n            exit(EXIT_FAILURE);\r\n        }\r\n        log(\"Socket has been binded\");\r\n        log(\"Listening for client\");\r\n        if (listen(server_fd, 3) < 0) {\r\n            perror(\"listen\");\r\n            exit(EXIT_FAILURE);\r\n        }\r\n    }\r\n\r\n    //accepting and receiving from the client\r\n    unsigned char * acceptAndReceive() {\r\n        memset(buffer, 0, sizeof(buffer));\r\n        log(\"Waiting for client request, Please wait...\");\r\n        if ((new_socket = accept(server_fd, (struct sockaddr * ) & address,\r\n                (socklen_t * ) & addrlen)) < 0) {\r\n            perror(\"accept\");\r\n            exit(EXIT_FAILURE);\r\n        }\r\n        valread = read( new_socket , (DES_cblock *)buffer, sizeof(buffer));\r\n        log(\"Request received...\");\r\n        return buffer;\r\n    }\r\n};\r\n\r\nclass DESDecrypt {\r\n    DES_cblock key = \"1234567\";\r\n    DES_cblock seed = {0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10};\r\n    DES_key_schedule keysched;\r\n    unsigned char back[BUFSIZE];\r\n    public:\r\n        void log(string message) {\r\n            cout << \"<Server>: \" << message << endl;\r\n        }\r\n    //decrypting the ciphertext after receiving \r\n    unsigned char* decrypt(unsigned char* cipher) {\r\n        memset(back, 0, sizeof(back));\r\n        RAND_seed(seed, sizeof(DES_cblock));\r\n        DES_set_key((DES_cblock *)key, &keysched);\r\n        DES_ecb_encrypt((DES_cblock *)cipher,(DES_cblock *)back, &keysched, DES_DECRYPT);\r\n        return back;\r\n    }\r\n};\r\n\r\nint main(int argc, char const * argv[]) {\r\n    Server server;\r\n    server.createSocket(PORT);\r\n    server.bindAndListenSocket();\r\n    unsigned char * cipher = server.acceptAndReceive();\r\n    \r\n    cout<<\"\\n ACK = Enrcypted message recieved\"<<endl;\r\n    cout<<\"\\n Now decrypting the encrypted message\"<<endl;\r\n    DESDecrypt des;\r\n    unsigned char* p = des.decrypt(cipher);    //decrypted cipher text is \r\n    printf(\"Plaintext=: [%s]\\n\",p);\r\n    return 0;\r\n}",
  "lab2": "\nlab2--cl.cpp\n#include <iostream>\r\n#include <openssl/evp.h>\r\n#include <openssl/ssl.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n\r\nusing namespace std;\r\n\r\nint main() {\r\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\r\n    if (sock == -1) {\r\n        cerr << \"Could not create socket\" << endl;\r\n        return -1;\r\n    }\r\n\r\n    struct sockaddr_in server;\r\n    server.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\r\n    server.sin_family = AF_INET;\r\n    server.sin_port = htons(1234);\r\n\r\n    if (connect(sock, (struct sockaddr *)&server, sizeof(server)) < 0) {\r\n        cerr << \"Connect failed\" << endl;\r\n        return -1;\r\n    }\r\n\r\n    EVP_CIPHER_CTX *ctx;\r\n\r\n    unsigned char key[] = \"0123456789abcdef\";\r\n    unsigned char iv[] = \"abcdefghijklmnop\";\r\n\r\n    unsigned char plaintext[] = \"My_self_UTKARSH\";\r\n    int plaintext_len = strlen((char *)plaintext);\r\n    cout<<\"Original message :\"<<plaintext<<endl;\r\n\r\n    unsigned char ciphertext[1024];\r\n    int ciphertext_len;\r\n\r\n    ctx = EVP_CIPHER_CTX_new();\r\n    EVP_EncryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, iv);\r\n    EVP_EncryptUpdate(ctx, ciphertext, &ciphertext_len, plaintext, plaintext_len);\r\n    EVP_EncryptFinal_ex(ctx, ciphertext + ciphertext_len, &ciphertext_len);\r\n    EVP_CIPHER_CTX_free(ctx);\r\n    \r\n    cout<<\"Message after encryping : \"<<ciphertext<<endl;\r\n\r\n    send(sock, (char *)ciphertext, strlen((char *)ciphertext), 0);\r\n    close(sock);\r\n\r\n    return 0;\r\n}\nlab2--s1.cpp\n#include <iostream>\r\n#include <openssl/evp.h>\r\n#include <openssl/ssl.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n\r\n\r\nusing namespace std;\r\n\r\nint main() {\r\n    int server_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n    if (server_sock == -1) {\r\n        cerr << \"Could not create socket\" << endl;\r\n        return -1;\r\n    }\r\n\r\n    int client_sock;\r\n    struct sockaddr_in server, client;\r\n    int c = sizeof(struct sockaddr_in);\r\n\r\n    server.sin_family = AF_INET;\r\n    server.sin_addr.s_addr = INADDR_ANY;\r\n    server.sin_port = htons(1234);\r\n\r\n    if (bind(server_sock, (struct sockaddr *)&server, sizeof(server)) < 0) {\r\n        cout << \"Bind failed\" << endl;\r\n        return -1;\r\n    }\r\n  \r\n    listen(server_sock, 3);\r\n\r\n    cout << \"Waiting for incoming connections...\" << endl;\r\n    client_sock = accept(server_sock, (struct sockaddr )&client, (socklen_t)&c);\r\n    if (client_sock < 0) {\r\n        cout << \"Accept failed\" << endl;\r\n        return -1;\r\n    }\r\n\r\n    EVP_CIPHER_CTX *ctx;\r\n\r\n    unsigned char key[] = \"0123456789abcdef\";\r\n    unsigned char iv[] = \"abcdefghijklmnop\";\r\n\r\n    unsigned char ciphertext[1024];\r\n    int ciphertext_len;\r\n\r\n    int bytes_read = recv(client_sock, (char *)ciphertext, 1024, 0);\r\n    cout<<ciphertext<<endl;\r\n    ciphertext[bytes_read] = '\\0';\r\n\r\n    unsigned char decryptedtext[2048];\r\n    int decryptedtext_len;\r\n\r\n    ctx = EVP_CIPHER_CTX_new();\r\n    EVP_DecryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, iv);\r\n    EVP_DecryptUpdate(ctx, decryptedtext, &decryptedtext_len, ciphertext, ciphertext_len);\r\n    EVP_DecryptFinal_ex(ctx, decryptedtext + decryptedtext_len, &decryptedtext_len);\r\n    EVP_CIPHER_CTX_free(ctx);\r\n\r\n    cout << \"Decrypted message: \"<< decryptedtext;\r\n\r\n    close(client_sock);\r\n    close(server_sock);\r\n\r\n    return 0;\r\n}",
  "lab3": "\nlab3--rc4c.cpp\n//for compile : g++ -o rc4c rc4c.cpp \n//for run : ./rc4c\n#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\nusing namespace std;\n\n// Function to generate RC4 key stream\nvoid RC4(unsigned char *key, int key_length, unsigned char *input, int input_length, unsigned char *output) {\n    // Initialization\n    unsigned char S[256], K[256];\n    for (int i = 0; i < 256; i++) {\n        S[i] = i;\n        K[i] = key[i % key_length];\n    }\n    int j = 0;\n    for (int i = 0; i < 256; i++) {\n        j = (j + S[i] + K[i]) % 256;\n        swap(S[i], S[j]);\n    }\n    // Stream generation\n    int i = 0, k = 0;\n    for (int n = 0; n < input_length; n++) {\n        i = (i + 1) % 256;\n        j = (j + S[i]) % 256;\n        swap(S[i], S[j]);\n        k = S[(S[i] + S[j]) % 256];\n        output[n] = input[n] ^ k;\n    }\n}\n\nint main() {\n    int sock = 0, valread;\n    struct sockaddr_in serv_addr;\n    string key_str = \"secretkey\";\n    int key_length = key_str.length();\n    unsigned char key[key_length];\n    \n    // Convert the key to an unsigned char array\n    memcpy(key, key_str.c_str(), key_length);\n    \n    // Create a socket file descriptor\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        printf(\"\\n Socket creation error \\n\");\n        return -1;\n    }\n    \n    // Set server address\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8080);\n    \n    // Convert IPv4 and IPv6 addresses from text to binary form\n    inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr);\n    \n    // Connect to the server\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        printf(\"\\nConnection Failed \\n\");\n        return -1;\n    }\n    \n    // Send plaintext to the server\n    unsigned char plaintext[] = \"Hello, server! I am UKARSH UPADHYAY\";\n    printf(\"%s\\n\",plaintext);\n    \n     // Encrypt the plaintext\n    int plaintext_length = strlen((const char*)plaintext);\n    unsigned char ciphertext[plaintext_length];\n    RC4(key, key_length, plaintext, plaintext_length, ciphertext);\n    printf(\"Ciphertext generated: %s\\n\", ciphertext);\n    \n    //ciphertext send to the server\n    send(sock, ciphertext, strlen((const char*)ciphertext), 0);\n    printf(\"ciphertext sent to server:\\n\");\n    return 0;\n}\n\nlab3--rc4s.cpp\n//for compile : g++ -o rc4s rc4s.cpp \n//for run : ./rc4s\n#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\nusing namespace std;\n\n// Function to generate RC4 key stream\nvoid RC4(unsigned char *key, int key_length, unsigned char *input, int input_length, unsigned char *output) {\n    // Initialization\n    unsigned char S[256], K[256];\n    for (int i = 0; i < 256; i++) {\n        S[i] = i;\n        K[i] = key[i % key_length];\n    }\n    int j = 0;\n    for (int i = 0; i < 256; i++) {\n        j = (j + S[i] + K[i]) % 256;\n        swap(S[i], S[j]);\n    }\n    // Stream generation\n    int i = 0, k = 0;\n    for (int n = 0; n < input_length; n++) {\n        i = (i + 1) % 256;\n        j = (j + S[i]) % 256;\n        swap(S[i], S[j]);\n        k = S[(S[i] + S[j]) % 256];\n        output[n] = input[n] ^ k;\n    }\n}\n\nint main() {\n    int server_fd, new_socket, valread;\n    struct sockaddr_in address;\n    int opt = 1;\n    int addrlen = sizeof(address);\n    string key_str = \"secretkey\";\n    int key_length = key_str.length();\n    unsigned char key[key_length];\n    \n    // Convert the key to an unsigned char array\n    memcpy(key, key_str.c_str(), key_length);\n    \n    // Create a server socket \n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n    \n    // Set server address\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(8080);\n    \n    // Bind the socket to the specified address and port\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        exit(EXIT_FAILURE);\n    }\n    \n    // Listen for incoming connections\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        exit(EXIT_FAILURE);\n    }\n    \n    // Accept incoming connections\n    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n        perror(\"accept\");\n        exit(EXIT_FAILURE);\n    }\n    \n    // Receive plaintext from the client\n    unsigned char ciphertext[1024] = {0};\n    valread = read(new_socket, ciphertext, 1024);\n    printf(\"ciphertext received from client: %s\\n\", ciphertext);\n\n     // Decrypt the ciphertext\n    int ciphertext_length = strlen((const char*)ciphertext);\n    unsigned char decrypted_text[ciphertext_length];\n    RC4(key, key_length, ciphertext, ciphertext_length, decrypted_text);\n    printf(\"Decrypted text: %s\\n\", decrypted_text);  \n    return 0;\n}\n",
  "lab4": "\nlab4-AES-aes_client.cpp\n// to compile : g++ aes_client.cpp -o aes_client -lssl -lcrypto\n// to run : ./aes_client\n#include <iostream>\n#include <string.h>\nusing namespace std;\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <openssl/aes.h>\n\n#define PORT 8080\n#define AES_KEY_SIZE 128\n\nvoid aes_decrypt(const unsigned char *ciphertext, int ciphertext_len, const unsigned char *key, unsigned char *plaintext) {\n    AES_KEY aes_key;\n    AES_set_decrypt_key(key, AES_KEY_SIZE, &aes_key);\n    AES_decrypt(ciphertext, plaintext, &aes_key);\n}\n\nint main(int argc, char const *argv[])\n{\n    int sock = 0, valread;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    // Create socket file descriptor\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n    {\n        std::cout << \"Socket creation error\" << std::endl;\n        return -1;\n    }\n\n    // Set server address and port\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(PORT);\n\n    // Convert IPv4 and IPv6 addresses from text to binary form\n    if(inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr)<=0)\n    {\n        std::cout << \"Invalid address/ Address not supported\" << std::endl;\n        return -1;\n    }\n\n    // Connect to server\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n    {\n        std::cout << \"Connection Failed\" << std::endl;\n        return -1;\n    }\n\n    std::cout << \"Connected to server\" << std::endl;\n\n    // Send plaintext message to server\n    char* plaintext = \"Hello, server!\";\n    cout<<\"This message will be send to server:\" <<plaintext<<\"\\n\";\n    send(sock, plaintext, strlen(plaintext), 0);\n\n    // Receive encrypted message from server\n    unsigned char key[AES_KEY_SIZE / 8] = \"0123456789\";\n    unsigned char ciphertext[1024] = {0};\n    valread = read(sock, ciphertext, 1024);\n\n    // Decrypt received message with AES\n    unsigned char decrypted_text[1024] = {0};\n    aes_decrypt(ciphertext, strlen((char*)ciphertext), key, decrypted_text);\n\n    std::cout << \"Encrypted message received: \" << ciphertext << std::endl;\n    std::cout << \"Decrypted message: \" << decrypted_text << std::endl;\n\n    // Close the socket\n    close(sock);\n\n    return 0;\n}\n\n\nlab4-AES-aes_server.cpp\n// to compile : g++ aes_server.cpp -o aes_server -lssl -lcrypto\n// to run : ./aes_server\n#include <iostream>\nusing namespace std;\n#include <string.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <openssl/aes.h>\n\n#define PORT 8080\n#define AES_KEY_SIZE 128\n\nvoid aes_encrypt(const unsigned char *plaintext, int plaintext_len, const unsigned char *key, unsigned char *ciphertext) {\n    AES_KEY aes_key;\n    AES_set_encrypt_key(key, AES_KEY_SIZE, &aes_key);\n    AES_encrypt(plaintext, ciphertext, &aes_key);\n}\n\nint main(int argc, char const *argv[])\n{\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int opt = 1;\n    int addrlen = sizeof(address);\n\n    // Create socket file descriptor\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0)\n    {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Bind socket to address and port\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(PORT);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address))<0)\n    {\n        perror(\"bind failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Listen for incoming connections\n    if (listen(server_fd, 3) < 0)\n    {\n        perror(\"listen failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    std::cout << \"Server listening on port \" << PORT << std::endl;\n\n    // Accept incoming connections\n    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen))<0)\n    {\n        perror(\"accept failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    std::cout << \"Client connected\" << std::endl;\n\n    // Receive plaintext message from client\n    char buffer[1024] = {0};\n    int valread = read(new_socket, buffer, 1024);\n    cout<<\"plaintext received from client is :\" <<buffer<<\"\\n\";\n\n    // Encrypt plaintext message with AES\n    unsigned char key[AES_KEY_SIZE / 8] = \"0123456789\";\n    unsigned char ciphertext[1024] = {0};\n    aes_encrypt((unsigned char*)buffer, strlen(buffer), key, ciphertext);\n    cout<<\"encrypted plaintext is :\" <<ciphertext<<\"\\n\";\n\n    // Send encrypted message to client\n    send(new_socket, ciphertext, strlen((char*)ciphertext), 0);\n\n    std::cout << \"encrpted Message sent to server\" << std::endl;\n\n    // Close the socket\n    close(new_socket);\n    close(server_fd);\n\n    return 0;\n}\n\n\nlab4-AES-aes_source_file.cpp\n/*\r\nby- SHARAD VERMA\r\nimplementation of 128 bit AES encryption and decryption\r\n-> key for encryption and decryption is stored in file key.txt\r\nwhile encryption -\r\n-> reads plain text from input.txt\r\n-> stores encrypted data in encryption.aes\r\nwhile decryption -\r\n-> program reads encrypted data from encryption.text\r\n-> decrypted data is stored in outputtext.txt file\r\n*/\r\n#include<iostream>\r\n#include<fstream>\r\n#include<cstring>\r\n#include<sstream>\r\n#include \"key_expand.h\"\r\n#include \"encoding.h\"\r\n#include \"decoding.h\"\r\n#include <typeinfo>\r\n#include<windows.h>\r\nusing namespace std;\r\nint main()\r\n{\r\n\t//we will read from file input.txt\r\nint extendedlength=0;\r\nint choice;\r\nstring myText;\r\nlabel:\r\n   cout<<\"Welcome to 128 bits AES encryption\"<<endl;\r\n   cout<<endl;\r\n   cout<<\"Enter you choice \"<<endl;\r\n   cout<<\"1- Encoding\"<<endl;\r\n   cout<<\"2- Decoding\"<<endl;\r\n   cin>>choice;\r\n\r\n  switch(choice)\r\n  {\r\n  \tcase 1:\r\n  \t\t{\r\n  \t//encryption of text data\r\n   ifstream File;\r\n   string filepath = \"encryption.aes\";\r\n    //clearing encryption.aes before editing\r\n   File.open(filepath.c_str(), std::ifstream::out | std::ifstream::trunc );\r\n   if (!File.is_open() || File.fail())\r\n   {\r\n   File.close();\r\n   printf(\"\\nError : failed to erase file content !\");\r\n   }\r\n   File.close();\r\n   //reading plain text from input.txt \r\n  \tfstream newfile;\r\n\tnewfile.open(\"input.txt\",ios::in); //open a file to perform read operation using file object\r\n   if (newfile.is_open()){   //checking whether the file is open\r\n      cout<<\"Reading plain text from input.txt .........\\n\";\r\n      Sleep(1000);\r\n      string tp;\r\n       cout<<\"Reading KEY from key.txt ......\\n\";\r\n      Sleep(1000);\r\n       cout<<\"Now encrypting ....\\n\";\r\n          Sleep(1000);\r\n        cout<<\"writing encrypted data in encryption.aes ..\\n\";\r\n          Sleep(1000);\r\n          cout<<endl;\r\n      while(getline(newfile, tp)){ \r\n\t  //read data from file object and put it into string.\r\n\t  int messlength=tp.length();\r\n\t  int extendedlength;\r\n\t   if((messlength%16)!=0)\r\n\t   {\r\n\t  \textendedlength=messlength+(16-(messlength%16));\r\n\t   }\r\n\t   else\r\n\t   {\r\n\t   \textendedlength=messlength;\r\n\t    }\r\n\t    unsigned char* encryptedtext=new unsigned char[extendedlength];\r\n\t    for(int i=0;i<extendedlength;i++)\r\n         {\r\n  \t       if(i<messlength)\r\n  \t       encryptedtext[i]=tp[i];\r\n  \t       else\r\n  \t       encryptedtext[i]=0;\r\n         }\r\n         //getting key from key.txt\r\n        string k;\r\n\t    ifstream infile;\r\n\t    infile.open(\"key.txt\");\r\n\t    if (infile.is_open())\r\n\t   {\r\n\t\tgetline(infile, k); // The first line of file should be the key\r\n\t\tinfile.close();\r\n\t   }\r\n\r\n\t   else cout << \"Unable to open file\";\r\n\t   \r\n\t    istringstream tempkey(k);\r\n\t    unsigned char key[16];\r\n\t    unsigned int x;\r\n\t    for(int i=0;i<16;i++)\r\n\t    {\r\n\t    tempkey>>hex>>x;\r\n\t\tkey[i] = x;\r\n\t    }\r\n\t    //extending key\r\n\t     unsigned char extendedkeys[176];\r\n         Key_extenxion(key,extendedkeys);\r\n         \r\n        //encrypting our plain text\r\n         for(int i=0;i<extendedlength;i+=16)\r\n         {\r\n          unsigned char* temp=new unsigned char[16];\r\n\t\t  for(int j=0;j<16;j++)\r\n\t\t  {\r\n\t\t  \ttemp[j]=encryptedtext[i+j];\r\n\t\t  }\t\r\n\t\t  encryption(temp , extendedkeys);\r\n\t\t  for(int j=0;j<16;j++)\r\n\t\t  {\r\n\t\t  \tencryptedtext[i+j]=temp[j];\r\n\t\t  }\t\r\n\t\t }\r\n\t//storing our encrypted data in encryption.aes\t \t\t \r\n\tofstream fout;  // Create Object of Ofstream\r\n    ifstream fin;\r\n    fin.open(\"encryption.aes\");\r\n    fout.open (\"encryption.aes\",ios::app); // Append mode\r\n    if(fin.is_open())\r\n        fout<<encryptedtext<<\"\\n\"; // Writing data to file\r\n    fin.close();\r\n    fout.close(); \r\n      }\r\n      cout<<\"128-bit AES encryption is done sucessfully\\n\";\r\n      cout<<\"Data has been appended to file encryption.aes\";\r\n      newfile.close(); //close the file object.\r\n   }\r\n  break;\r\n}\r\n\r\n\tcase 2:\r\n\t\t{\r\n\t  cout<<\"Reading encrypted data from encryption.txt .........\\n\";\r\n      Sleep(1000);\r\n      string tp;\r\n      cout<<\"Reading KEY from key.txt ......\\n\";\r\n      Sleep(1000);\r\n      cout<<\"Now Decrypting ....\\n\";\r\n      Sleep(1000);\r\n       cout<<\"writing decrypted data in outputtext.txt ..\\n\";\r\n          Sleep(1000);\r\n          cout<<endl;\r\n\tcout<<\"Following is our decrypted text:- \\n\";\r\n\t//clearing outputtext file\r\n\tifstream File;\r\n   string filepath = \"outputtext.txt\";\r\n   File.open(filepath.c_str(), std::ifstream::out | std::ifstream::trunc );\r\n   if (!File.is_open() || File.fail())\r\n   {\r\n   File.close();\r\n   printf(\"\\nError : failed to erase file content !\");\r\n   }\r\n   File.close();\r\n\r\n\tifstream MyReadFile;\r\n\tMyReadFile.open(\"encryption.aes\", ios::in | ios::binary);\r\n    if(MyReadFile.is_open())\r\n    {\r\n    while( getline (MyReadFile, myText) )\r\n   {\r\n   \tcout.flush();\r\n     char * x;\r\n      x=&myText[0];\r\n      int messlength=strlen(x);\r\n\t char * msg = new char[myText.size()+1];\r\n\r\n\tstrcpy(msg, myText.c_str());\r\n\r\n\tint n = strlen((const char*)msg);\r\n\tunsigned char * decryptedtext = new unsigned char[n];\r\n\t//decrypting our encrypted data\r\n\tfor (int i = 0; i < n; i++) {\r\n\t\tdecryptedtext[i] = (unsigned char)msg[i];\r\n\t}\r\n\t//reading key from key.txt file\r\n\t\t string k;\r\n\t    ifstream infile;\r\n\t    infile.open(\"key.txt\");\r\n\t    if (infile.is_open())\r\n\t   {\r\n\t\tgetline(infile, k); // The first line of file should be the key\r\n\t\tinfile.close();\r\n\t   }\r\n\r\n\t   else cout << \"Unable to open file\";\r\n\t    istringstream tempkey(k);\r\n\t    unsigned char key[16];\r\n\t    unsigned int x1;\r\n\t    for(int i=0;i<16;i++)\r\n\t    {\r\n\t    tempkey>>hex>>x1;\r\n\t\tkey[i] = x1;\r\n\t    }\r\n\t    //extending key\r\n        unsigned char extendedkeys[176];\r\n        Key_extenxion(key,extendedkeys);\r\n      //decrypting our data  \r\n      for (int i = 0; i < messlength; i += 16)\r\n      {\r\n        unsigned char * temp=new unsigned char[16];\r\n        for(int j=0;j<16;j++)\r\n        temp[j]=decryptedtext[i+j];\r\n\t\tdecryption(temp , extendedkeys);\r\n\t\tfor(int j=0;j<16;j++)\r\n            decryptedtext[i+j]=temp[j];\r\n      }\r\n      //printing our plain text\r\n\t\t\tfor(int i=0;i<messlength;i++)\r\n\t\t\t{\r\n\t\t\tcout<<decryptedtext[i];\r\n\t\t\tif(decryptedtext[i]==0 && decryptedtext[i-1]==0 )\r\n\t\t\tbreak;\r\n\t     \t}\r\n    //storing plain text in outputtext.txt file\r\n\t\t\t  cout<<endl;\r\n\t\t\t  ofstream fout;  // Create Object of Ofstream\r\n              ifstream fin;\r\n              fin.open(\"outputtext.txt\");\r\n              fout.open (\"outputtext.txt\",ios::app); // Append mode\r\n              if(fin.is_open())\r\n                fout<<decryptedtext<<\"\\n\"; // Writing data to file\r\n\r\n             fin.close();\r\n             fout.close(); // Closing the file\r\n         Sleep(500);\r\n\t\t}\r\n}\r\n\telse\r\n         {\r\n\t      cout<<\"Can not open input file\\n \";\r\n       }\r\n       cout<<\"\\n Data has been appended to file outputtext.txt\";\r\nMyReadFile.close();\r\nbreak;\r\n}\r\n}\r\n}\r\n\r\n\nlab4-DES-des_client.cpp\n// to compile : g++ des_client.cpp -o des_client -lssl -lcrypto\n// to run : ./des_client\n#include <iostream>\n#include <sys/socket.h>\nusing namespace std;\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <cstring>\n#include <openssl/des.h>\n\n#define PORT 8080\n\nusing namespace std;\n\nint main(int argc, char const *argv[]) {\n    int sock = 0, valread;\n    struct sockaddr_in serv_addr;\n    const char* message1 = \"Hello from client\";\n    cout<<message1<<\"\\n\";\n    char buffer[1024] = {0};\n\n    // Create socket\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        cout << \"Socket creation error\" << endl;\n        return -1;\n    }\n\n    // Set server address and port\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(PORT);\n\n    // Convert IPv4 and IPv6 addresses from text to binary form\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        cout << \"Invalid address/ Address not supported\" << endl;\n        return -1;\n    }\n\n    // Connect to server\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        cout << \"Connection Failed\" << endl;\n        return -1;\n    }\n\n    // Set up DES key and IV\n    DES_cblock key = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef};\n    DES_cblock iv = {0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80};\n    DES_key_schedule key_schedule;\n    DES_set_key(&key, &key_schedule);\n    \n    const char* message = \"hii_UTKARSH\";\n    cout<<\"plaintext is: \"<<message<<\"\\n\";\n\n    // Encrypt message using DES algorithm\n    char ciphertext[1024] = {0};\n    DES_ncbc_encrypt((const unsigned char *)message, (unsigned char *)ciphertext, strlen(message), &key_schedule, &iv, DES_ENCRYPT);\n    // Send encrypted message to server\n    send(sock, ciphertext, strlen(ciphertext), 0);\n    cout << \"Encrypted message sent to server: \"<<ciphertext << endl;\n\n    // Receive decrypted message from server\n    valread = read(sock, buffer, 1024);\n    cout << \"Decrypted message received from server \"<<endl;\n\n    return 0;\n}\n\n\nlab4-DES-des_server.cpp\n// to compile : g++ des_server.cpp -o des_server -lssl -lcrypto\n// to run : ./des_server\n#include <iostream>\n#include <string.h>\nusing namespace std;\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <openssl/des.h>\n\n#define PORT 8080\n\nint main(int argc, char const *argv[]) {\n    int server_fd, new_socket, valread;\n    struct sockaddr_in address;\n    int opt = 1;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n    char *hello = \"Hello from server\";\n    cout<<hello<<\"\\n\";\n    char key[] = \"secret_k\";\n    DES_cblock des_key = {0};\n    DES_key_schedule schedule;\n    DES_string_to_key(key, &des_key);\n    DES_set_key_checked(&des_key, &schedule);\n\n    // Creating socket file descriptor\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(PORT);\n\n    // Forcefully attaching socket to the port 8080\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address))<0) {\n        perror(\"bind failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        exit(EXIT_FAILURE);\n    }\n\n    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen))<0) {\n        perror(\"accept\");\n        exit(EXIT_FAILURE);\n    }\n\n    valread = read(new_socket, buffer, 1024);\n    std::string ciphertext(buffer, valread);\n\n    std::cout << \"Encrypted message received from client: \" << ciphertext << std::endl;\n\n    DES_cblock ivec = {0};\n    DES_ncbc_encrypt((unsigned char*)ciphertext.c_str(), (unsigned char*)buffer, ciphertext.size(), &schedule, &ivec, DES_DECRYPT);\n\n    std::string plaintext(buffer, strlen(buffer));\n\n    std::cout << \"Decrypted message: \" <<endl;\n\n    send(new_socket, plaintext.c_str(), plaintext.size(), 0);\n    std::cout << \"Decrypted message sent back to client\" <<endl;\n\n    return 0;\n}\n\n\nlab4-DES-des_source_file2.cpp\n// C++ code for the des algorithm\r\n\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\nstring hex2bin(string s)\r\n{\r\n\t// hexadecimal to binary conversion\r\n\tunordered_map<char, string> mp;\r\n\tmp['0'] = \"0000\";\r\n\tmp['1'] = \"0001\";\r\n\tmp['2'] = \"0010\";\r\n\tmp['3'] = \"0011\";\r\n\tmp['4'] = \"0100\";\r\n\tmp['5'] = \"0101\";\r\n\tmp['6'] = \"0110\";\r\n\tmp['7'] = \"0111\";\r\n\tmp['8'] = \"1000\";\r\n\tmp['9'] = \"1001\";\r\n\tmp['A'] = \"1010\";\r\n\tmp['B'] = \"1011\";\r\n\tmp['C'] = \"1100\";\r\n\tmp['D'] = \"1101\";\r\n\tmp['E'] = \"1110\";\r\n\tmp['F'] = \"1111\";\r\n\tstring bin = \"\";\r\n\tfor (int i = 0; i < s.size(); i++) {\r\n\t\tbin += mp[s[i]];\r\n\t}\r\n\treturn bin;\r\n}\r\nstring bin2hex(string s)\r\n{\r\n\t// binary to hexadecimal conversion\r\n\tunordered_map<string, string> mp;\r\n\tmp[\"0000\"] = \"0\";\r\n\tmp[\"0001\"] = \"1\";\r\n\tmp[\"0010\"] = \"2\";\r\n\tmp[\"0011\"] = \"3\";\r\n\tmp[\"0100\"] = \"4\";\r\n\tmp[\"0101\"] = \"5\";\r\n\tmp[\"0110\"] = \"6\";\r\n\tmp[\"0111\"] = \"7\";\r\n\tmp[\"1000\"] = \"8\";\r\n\tmp[\"1001\"] = \"9\";\r\n\tmp[\"1010\"] = \"A\";\r\n\tmp[\"1011\"] = \"B\";\r\n\tmp[\"1100\"] = \"C\";\r\n\tmp[\"1101\"] = \"D\";\r\n\tmp[\"1110\"] = \"E\";\r\n\tmp[\"1111\"] = \"F\";\r\n\tstring hex = \"\";\r\n\tfor (int i = 0; i < s.length(); i += 4) {\r\n\t\tstring ch = \"\";\r\n\t\tch += s[i];\r\n\t\tch += s[i + 1];\r\n\t\tch += s[i + 2];\r\n\t\tch += s[i + 3];\r\n\t\thex += mp[ch];\r\n\t}\r\n\treturn hex;\r\n}\r\n\r\nstring permute(string k, int* arr, int n)\r\n{\r\n\tstring per = \"\";\r\n\tfor (int i = 0; i < n; i++) {\r\n\t\tper += k[arr[i] - 1];\r\n\t}\r\n\treturn per;\r\n}\r\n\r\nstring shift_left(string k, int shifts)\r\n{\r\n\tstring s = \"\";\r\n\tfor (int i = 0; i < shifts; i++) {\r\n\t\tfor (int j = 1; j < 28; j++) {\r\n\t\t\ts += k[j];\r\n\t\t}\r\n\t\ts += k[0];\r\n\t\tk = s;\r\n\t\ts = \"\";\r\n\t}\r\n\treturn k;\r\n}\r\n\r\nstring xor_(string a, string b)\r\n{\r\n\tstring ans = \"\";\r\n\tfor (int i = 0; i < a.size(); i++) {\r\n\t\tif (a[i] == b[i]) {\r\n\t\t\tans += \"0\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\tans += \"1\";\r\n\t\t}\r\n\t}\r\n\treturn ans;\r\n}\r\nstring encrypt(string pt, vector<string> rkb,\r\n\t\t\tvector<string> rk)\r\n{\r\n\t// Hexadecimal to binary\r\n\tpt = hex2bin(pt);\r\n\r\n\t// Initial Permutation Table\r\n\tint initial_perm[64]\r\n\t\t= { 58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44,\r\n\t\t\t36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22,\r\n\t\t\t14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57,\r\n\t\t\t49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35,\r\n\t\t\t27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13,\r\n\t\t\t5, 63, 55, 47, 39, 31, 23, 15, 7 };\r\n\t// Initial Permutation\r\n\tpt = permute(pt, initial_perm, 64);\r\n\tcout << \"After initial permutation: \" << bin2hex(pt)\r\n\t\t<< endl;\r\n\r\n\t// Splitting\r\n\tstring left = pt.substr(0, 32);\r\n\tstring right = pt.substr(32, 32);\r\n\tcout << \"After splitting: L0=\" << bin2hex(left)\r\n\t\t<< \" R0=\" << bin2hex(right) << endl;\r\n\r\n\t// Expansion D-box Table\r\n\tint exp_d[48]\r\n\t\t= { 32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9,\r\n\t\t\t8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17,\r\n\t\t\t16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,\r\n\t\t\t24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1 };\r\n\r\n\t// S-box Table\r\n\tint s[8][4][16] = {\r\n\t\t{ 14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5,\r\n\t\t9, 0, 7, 0, 15, 7, 4, 14, 2, 13, 1, 10, 6,\r\n\t\t12, 11, 9, 5, 3, 8, 4, 1, 14, 8, 13, 6, 2,\r\n\t\t11, 15, 12, 9, 7, 3, 10, 5, 0, 15, 12, 8, 2,\r\n\t\t4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13 },\r\n\t\t{ 15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12,\r\n\t\t0, 5, 10, 3, 13, 4, 7, 15, 2, 8, 14, 12, 0,\r\n\t\t1, 10, 6, 9, 11, 5, 0, 14, 7, 11, 10, 4, 13,\r\n\t\t1, 5, 8, 12, 6, 9, 3, 2, 15, 13, 8, 10, 1,\r\n\t\t3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9 },\r\n\r\n\t\t{ 10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12,\r\n\t\t7, 11, 4, 2, 8, 13, 7, 0, 9, 3, 4,\r\n\t\t6, 10, 2, 8, 5, 14, 12, 11, 15, 1, 13,\r\n\t\t6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12,\r\n\t\t5, 10, 14, 7, 1, 10, 13, 0, 6, 9, 8,\r\n\t\t7, 4, 15, 14, 3, 11, 5, 2, 12 },\r\n\t\t{ 7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11,\r\n\t\t12, 4, 15, 13, 8, 11, 5, 6, 15, 0, 3, 4, 7,\r\n\t\t2, 12, 1, 10, 14, 9, 10, 6, 9, 0, 12, 11, 7,\r\n\t\t13, 15, 1, 3, 14, 5, 2, 8, 4, 3, 15, 0, 6,\r\n\t\t10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14 },\r\n\t\t{ 2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13,\r\n\t\t0, 14, 9, 14, 11, 2, 12, 4, 7, 13, 1, 5, 0,\r\n\t\t15, 10, 3, 9, 8, 6, 4, 2, 1, 11, 10, 13, 7,\r\n\t\t8, 15, 9, 12, 5, 6, 3, 0, 14, 11, 8, 12, 7,\r\n\t\t1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3 },\r\n\t\t{ 12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14,\r\n\t\t7, 5, 11, 10, 15, 4, 2, 7, 12, 9, 5, 6, 1,\r\n\t\t13, 14, 0, 11, 3, 8, 9, 14, 15, 5, 2, 8, 12,\r\n\t\t3, 7, 0, 4, 10, 1, 13, 11, 6, 4, 3, 2, 12,\r\n\t\t9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13 },\r\n\t\t{ 4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5,\r\n\t\t10, 6, 1, 13, 0, 11, 7, 4, 9, 1, 10, 14, 3,\r\n\t\t5, 12, 2, 15, 8, 6, 1, 4, 11, 13, 12, 3, 7,\r\n\t\t14, 10, 15, 6, 8, 0, 5, 9, 2, 6, 11, 13, 8,\r\n\t\t1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12 },\r\n\t\t{ 13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5,\r\n\t\t0, 12, 7, 1, 15, 13, 8, 10, 3, 7, 4, 12, 5,\r\n\t\t6, 11, 0, 14, 9, 2, 7, 11, 4, 1, 9, 12, 14,\r\n\t\t2, 0, 6, 10, 13, 15, 3, 5, 8, 2, 1, 14, 7,\r\n\t\t4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11 }\r\n\t};\r\n\r\n\t// Straight Permutation Table\r\n\tint per[32]\r\n\t\t= { 16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23,\r\n\t\t\t26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27,\r\n\t\t\t3, 9, 19, 13, 30, 6, 22, 11, 4, 25 };\r\n\r\n\tcout << endl;\r\n\tfor (int i = 0; i < 16; i++) {\r\n\t\t// Expansion D-box\r\n\t\tstring right_expanded = permute(right, exp_d, 48);\r\n\r\n\t\t// XOR RoundKey[i] and right_expanded\r\n\t\tstring x = xor_(rkb[i], right_expanded);\r\n\r\n\t\t// S-boxes\r\n\t\tstring op = \"\";\r\n\t\tfor (int i = 0; i < 8; i++) {\r\n\t\t\tint row = 2 * int(x[i * 6] - '0')\r\n\t\t\t\t\t+ int(x[i * 6 + 5] - '0');\r\n\t\t\tint col = 8 * int(x[i * 6 + 1] - '0')\r\n\t\t\t\t\t+ 4 * int(x[i * 6 + 2] - '0')\r\n\t\t\t\t\t+ 2 * int(x[i * 6 + 3] - '0')\r\n\t\t\t\t\t+ int(x[i * 6 + 4] - '0');\r\n\t\t\tint val = s[i][row][col];\r\n\t\t\top += char(val / 8 + '0');\r\n\t\t\tval = val % 8;\r\n\t\t\top += char(val / 4 + '0');\r\n\t\t\tval = val % 4;\r\n\t\t\top += char(val / 2 + '0');\r\n\t\t\tval = val % 2;\r\n\t\t\top += char(val + '0');\r\n\t\t}\r\n\t\t// Straight D-box\r\n\t\top = permute(op, per, 32);\r\n\r\n\t\t// XOR left and op\r\n\t\tx = xor_(op, left);\r\n\r\n\t\tleft = x;\r\n\r\n\t\t// Swapper\r\n\t\tif (i != 15) {\r\n\t\t\tswap(left, right);\r\n\t\t}\r\n\t\tcout << \"Round \" << i + 1 << \" \" << bin2hex(left)\r\n\t\t\t<< \" \" << bin2hex(right) << \" \" << rk[i]\r\n\t\t\t<< endl;\r\n\t}\r\n\r\n\t// Combination\r\n\tstring combine = left + right;\r\n\r\n\t// Final Permutation Table\r\n\tint final_perm[64]\r\n\t\t= { 40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47,\r\n\t\t\t15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22,\r\n\t\t\t62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36,\r\n\t\t\t4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11,\r\n\t\t\t51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58,\r\n\t\t\t26, 33, 1, 41, 9, 49, 17, 57, 25 };\r\n\r\n\t// Final Permutation\r\n\tstring cipher\r\n\t\t= bin2hex(permute(combine, final_perm, 64));\r\n\treturn cipher;\r\n}\r\n\r\n// Driver code\r\nint main()\r\n{\r\n\t// pt is plain text\r\n\tstring pt, key;\r\n\t/*cout<<\"Enter plain text(in hexadecimal): \";\r\n\tcin>>pt;\r\n\tcout<<\"Enter key(in hexadecimal): \";\r\n\tcin>>key;*/\r\n\r\n\tpt = \"123456ABCD132536\";\r\n\tkey = \"AABB09182736CCDD\";\r\n\t// Key Generation\r\n\r\n\t// Hex to binary\r\n\tkey = hex2bin(key);\r\n\r\n\t// Parity bit drop table\r\n\tint keyp[56]\r\n\t\t= { 57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34,\r\n\t\t\t26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3,\r\n\t\t\t60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7,\r\n\t\t\t62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37,\r\n\t\t\t29, 21, 13, 5, 28, 20, 12, 4 };\r\n\r\n\t// getting 56 bit key from 64 bit using the parity bits\r\n\tkey = permute(key, keyp, 56); // key without parity\r\n\r\n\t// Number of bit shifts\r\n\tint shift_table[16] = { 1, 1, 2, 2, 2, 2, 2, 2,\r\n\t\t\t\t\t\t\t1, 2, 2, 2, 2, 2, 2, 1 };\r\n\r\n\t// Key- Compression Table\r\n\tint key_comp[48] = { 14, 17, 11, 24, 1, 5, 3, 28,\r\n\t\t\t\t\t\t15, 6, 21, 10, 23, 19, 12, 4,\r\n\t\t\t\t\t\t26, 8, 16, 7, 27, 20, 13, 2,\r\n\t\t\t\t\t\t41, 52, 31, 37, 47, 55, 30, 40,\r\n\t\t\t\t\t\t51, 45, 33, 48, 44, 49, 39, 56,\r\n\t\t\t\t\t\t34, 53, 46, 42, 50, 36, 29, 32 };\r\n\r\n\t// Splitting\r\n\tstring left = key.substr(0, 28);\r\n\tstring right = key.substr(28, 28);\r\n\r\n\tvector<string> rkb; // rkb for RoundKeys in binary\r\n\tvector<string> rk; // rk for RoundKeys in hexadecimal\r\n\tfor (int i = 0; i < 16; i++) {\r\n\t\t// Shifting\r\n\t\tleft = shift_left(left, shift_table[i]);\r\n\t\tright = shift_left(right, shift_table[i]);\r\n\r\n\t\t// Combining\r\n\t\tstring combine = left + right;\r\n\r\n\t\t// Key Compression\r\n\t\tstring RoundKey = permute(combine, key_comp, 48);\r\n\r\n\t\trkb.push_back(RoundKey);\r\n\t\trk.push_back(bin2hex(RoundKey));\r\n\t}\r\n\r\n\tcout << \"\\nEncryption:\\n\\n\";\r\n\tstring cipher = encrypt(pt, rkb, rk);\r\n\tcout << \"\\nCipher Text: \" << cipher << endl;\r\n\r\n\tcout << \"\\nDecryption\\n\\n\";\r\n\treverse(rkb.begin(), rkb.end());\r\n\treverse(rk.begin(), rk.end());\r\n\tstring text = encrypt(cipher, rkb, rk);\r\n\tcout << \"\\nPlain Text: \" << text << endl;\r\n}\r\n",
  "lab5": "\nlab5--peer1.cpp\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\nusing namespace std;\n\nconst int PORT = 8080;\nconst char* SERVER_IP = \"127.0.0.1\";\n\nint main() {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int opt = 1;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n    const char* hello = \"Hello Peer2Peer From Node 1!\";\n\n    // Create a socket\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(PORT);\n\n    // Bind the socket to the specified IP address and port\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Listen for incoming connections\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        exit(EXIT_FAILURE);\n    }\n    \n    cout << \"Peer 1 is listening for incoming connections on port 8080\" <<endl;\n    \n    // Accept an incoming connection\n    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n        perror(\"accept\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Receive a message from the client\n    int valread = read(new_socket, buffer, 1024);\n    cout << buffer << endl;\n\n    // Send a message to the client\n    send(new_socket, hello, strlen(hello), 0);\n    cout << \"Received message from Peer 2: \" << buffer <<endl;\n    cout << \"Hello message sent\" << endl;\n\n    return 0;\n}\n\n\nlab5--peer2.cpp\n#include <iostream>\nusing namespace std;\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <cstring>\n\nconst int PORT = 8081;\nint main() {\n    // create a socket\n    int server_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_fd < 0) {\n        cout << \"Failed to create socket\" <<endl;\n        return 1;\n    }\n\n    // bind the socket to a port\n    struct sockaddr_in address;\n    memset(&address, 0, sizeof(address));\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(PORT);\n\n    int bind_result = bind(server_fd, (struct sockaddr *)&address, sizeof(address));\n    if (bind_result < 0) {\n        cout << \"Failed to bind socket to port\" <<endl;\n        return 1;\n    }\n\n    // start listening for incoming connections\n    int listen_result = listen(server_fd, 1);\n    if (listen_result < 0) {\n        cout<< \"Failed to listen for incoming connections\" <<endl;\n        return 1;\n    }\n\n    cout << \"Peer 2 is listening for incoming connections on port 8081\" <<endl;\n\n    // accept incoming connections and handle them\n        int client_fd = accept(server_fd, NULL, NULL);\n        if (client_fd < 0) {\n            cout << \"Failed to accept incoming connection\" <<endl;\n        }\n\n        char buffer[1024] = {0};\n        int bytes_read = read(client_fd, buffer, 1024);\n        if (bytes_read < 0) {\n            cout<< \"Failed to read data from socket\" <<endl;\n            close(client_fd);\n        }\n\n        cout << \"Received message from Peer 1: \" << buffer <<endl;\n\n        const char* response = \"Hello Peer2Peer From Node 2!\";\n        int bytes_sent = send(client_fd, response, strlen(response), 0);\n        if (bytes_sent < 0) {\n            cout<< \"Failed to send data to socket\" <<endl;\n        }\n\n        close(client_fd);\n\n    return 0;\n}\n\n",
  "lab6": "\nlab6--Wormhole.java\npackage network_security;\r\nimport java.util.*;\r\npublic class Wormhole {\r\n\t\r\n\t\r\n\tpublic static void displayGraph(int graph[][]) {\r\n\r\n\t\tfor (int i = 0; i < graph.length; i++) {\r\n\t\t    for (int j = 0; j < graph.length; j++) {\r\n\t\t      System.out.print(graph[i][j]+\" \");\r\n\t\t    }\r\n\t\t    System.out.println();\r\n\t\t}\r\n\t}\r\n\t//degree of a vertex\r\n\tpublic static int[] degree(int[][] graph) \r\n\t    {\t\r\n\t\t\tint[] old_degree = new int[50];\r\n\t        for(int j = 0;j<50;j++) {\r\n\t        \tint degree = 0;\r\n\t        \tfor (int i = 0; i < graph.length; i++) {\r\n\t        \t\tif (graph[j][i] < 10)\r\n\t        \t\t\tdegree++;\r\n\t        \t}\r\n\t        \told_degree[j]=degree;\r\n\t        }\r\n\t        return old_degree;\r\n\t    }\r\n\t\r\n\t//floyd warshall to calculate all pair shortest path\r\n\tpublic static void calculateShortestPath(int graph[][]) {\r\n\r\n\t  int i, j, k;\r\n\t for (k = 0; k < graph.length; k++)\r\n\t    for (i = 0; i < graph.length; i++)\r\n\t      for (j = 0; j < graph.length; j++)\r\n\t        if (graph[i][k] + graph[k][j] < graph[i][j])\r\n\t        \tgraph[i][j] = graph[i][k] + graph[k][j];\r\n\t}\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t\t\r\n\t\t//graph\r\n\t\tint [][] net = new int[50][2];\r\n\t\tRandom rand = new Random();\r\n\t\tfor(int i =0;i<50;i++) {\r\n\t\t\tnet[i][0]=rand.nextInt(100);\r\n\t\t\tnet[i][1]=rand.nextInt(100);\r\n\t\t}\r\n\t\t//graph adjacency matrix form by calculating distance between two points\r\n\t\tint[][] graph = new int[50][50];\r\n\t\tfor (int i = 0; i < 50; i++) {\r\n\t\t    for (int j = 0; j < 50; j++) {\r\n\t\t      graph[i][j] = (int)Math.sqrt((net[i][0] - net[j][0]) * (net[i][0] - net[j][0]) + (net[i][1] - net[j][1]) * (net[i][1] - net[j][1]));\r\n\t\t    }\r\n\t\t}\r\n\t\t//degree distribution before adding wormholes\r\n\t\tSystem.out.println(\"degree distribution before adding wormhole.............\");\r\n\t\tint[] old_degree = degree(graph);\r\n \t\tfor(int i =0;i<50;i++) {\r\n\t\t\tSystem.out.println(\"degree of point \"+i+\" : \"+old_degree[i]);\r\n\t\t}\r\n \t\tSystem.out.println();\r\n \t\t\r\n\t\t//shortest path distribution before adding wormholes\r\n\t\tcalculateShortestPath(graph);\r\n\t\tSystem.out.println(\"shortest path distribution before adding wormholes............\");\r\n\t\tdisplayGraph(graph);\r\n\t\tSystem.out.println();\r\n\t\t\r\n\t\t//add wormholes\r\n\t\tSystem.out.println(\"Adding random wormholes\");\r\n\t\tint [][] new_graph = graph;\r\n\t\twhile (true) {\r\n\t\t    int i = rand.nextInt(49);\r\n\t\t    int j = rand.nextInt(49);\r\n\t\t    if (i != j) {\r\n\t\t      if (new_graph[i][j] != 0 && new_graph[i][j] != 1) {\r\n\t\t    \t  new_graph[i][j] = 1;\r\n\t\t    \t  new_graph[j][i] = 1;\r\n\t\t    \t  System.out.println(\"nodes \"+i+\" and \"+j+\" are changed as wormholes\");\r\n\t\t    \t  break;\r\n\t\t      }\r\n\t\t    }\r\n\t\t  }\r\n\t\tSystem.out.println();\r\n\t\t\r\n\t\t//degree distribution after adding wormholes\r\n\t\tSystem.out.println(\"degree distribution after adding wormholes............\");\r\n\t\tint[] new_degree = degree(graph);\r\n \t\tfor(int i =0;i<50;i++) {\r\n\t\t\tSystem.out.println(\"degree of point \"+i+\" : \"+new_degree[i]);\r\n\t\t}\r\n \t\tSystem.out.println();\r\n \t\t\r\n \t\t\r\n\t\t//shortest path distribution after adding wormholes\r\n \t\tSystem.out.println(\"shortest path distribution after adding wormholes.........\");\r\n\t\tcalculateShortestPath(new_graph);\r\n\t\tdisplayGraph(new_graph);\r\n\t\tSystem.out.println();\r\n\t\t\r\n\t\t//detecting wormholes\r\n\t\tSystem.out.println(\"wormhole nodes are\");\r\n\t\tfor(int i =0;i<50;i++) {\r\n\t\t\tif(old_degree[i]!=new_degree[i])\r\n\t\t\t\tSystem.out.println(i);\r\n\t\t}\t\t\r\n\t\t\r\n\t}\r\n\r\n}\r\n",
  "lab7": "\nlab7-blackhole_attack-destination.cpp\n// Requires ssl and crypto libraries via -l flag\n#include <iostream>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <cstring>\n#include <arpa/inet.h>\n#include <unistd.h>\n\n\n// SYMMETRIC KEY ENCRYPTION AND DECRYPTION\nvoid encrypt(char *data, int data_len, const char *encryption_key) {\n    for (int i = 0; i < data_len; i++) {\n        data[i] = data[i] ^ encryption_key[i % strlen(encryption_key)];\n    }\n}\n\nint main() {\n    // RELAY NODE SOCKET\n    struct sockaddr_in relay_node_address;\n    relay_node_address.sin_port = htons(5678);\n    relay_node_address.sin_family = AF_INET;\n    inet_pton(AF_INET, \"127.0.0.1\", &relay_node_address.sin_addr);\n\n    // CONNECT TO RELAY\n    int destination_socket = socket(AF_INET, SOCK_STREAM, 0);\n    bind(destination_socket, (struct sockaddr *) &relay_node_address, sizeof(relay_node_address));\n\n    // Listen for incoming connections from the relay node\n    listen(destination_socket, 5);\n    std::cout << \"Waiting for incoming connections from relay node...\" << std::endl;\n\n    // Accept incoming connection from the relay node\n    struct sockaddr_in relay_node_address_client;\n    socklen_t client_address_size = sizeof(relay_node_address_client);\n    int relay_node_socket = accept(destination_socket, (struct sockaddr *) &relay_node_address_client,\n                                   &client_address_size);\n    std::cout << \"Received connection from relay node \" << inet_ntoa(relay_node_address_client.sin_addr) << \":\"\n              << ntohs(relay_node_address_client.sin_port) << std::endl;\n\n    while(1) {\n        // Receive encrypted data from the relay node\n        char received_message[1024];\n        memset(received_message, 0, sizeof(received_message));\n        int bytes_received = recv(relay_node_socket, received_message, sizeof(received_message), 0);\n        std::cout << \"receive encrypted data from relay node: \" << received_message << std::endl;\n\n        // Decrypt the received data\n        char decryption_key[] = \"anothersecret\";\n        encrypt(received_message, bytes_received, decryption_key);\n        std::cout << \"Received message from relay node:\" << received_message << std::endl;\n\n        // Send encrypted acknowledgment to the relay node\n        char message[] = \"Acknowledgment from destination node!\";\n        encrypt(message, strlen(message), decryption_key);\n        send(relay_node_socket, message, strlen(message), 0);\n        sleep(1);\n    }\n\n    return 0;\n}\nlab7-blackhole_attack-relay.cpp\n// Requires ssl and crypto libraries via -l flag\n#include <iostream>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <cstring>\n#include <arpa/inet.h>\n#include <random>\nint main() {\n    // source\n    struct sockaddr_in source_node_address;\n    source_node_address.sin_family = AF_INET;\n    source_node_address.sin_port = htons(1234);\n    inet_pton(AF_INET, \"127.0.0.1\", &source_node_address.sin_addr);\n\n    // destination\n    struct sockaddr_in destination_node_address;\n    destination_node_address.sin_family = AF_INET;\n    destination_node_address.sin_port = htons(5678);\n    inet_pton(AF_INET, \"127.0.0.1\", &destination_node_address.sin_addr);\n\n    // connect to source\n    int relay_socket = socket(AF_INET, SOCK_STREAM, 0);\n    bind(relay_socket, (struct sockaddr*) &source_node_address, sizeof(source_node_address));\n\n    // wait till source sends message\n    listen(relay_socket, 1);\n    std::cout << \"Waiting for incoming connections from source node...\" << std::endl;\n\n    // accept connection from source\n    int source_socket = accept(relay_socket, NULL, NULL);\n    int destination_socket = socket(AF_INET, SOCK_STREAM, 0);\n    connect(destination_socket, (struct sockaddr*) &destination_node_address, sizeof(destination_node_address));\n\n    int receivedPackets = 0, forwardedPackets = 0;\n    while(true) {\n        // receive encrypted message from source\n        char received_message[1024];\n        memset(received_message, 0, sizeof(received_message));\n        int bytes_received = recv(source_socket, received_message, sizeof(received_message), 0);\n        std::cout << \"receive encrypted data from source node: \" << received_message << std::endl;\n\n        // decrypt\n        char decryption_key[] = \"secret\";\n        for (int i = 0; i < bytes_received; i++) {\n            received_message[i] = received_message[i] ^ decryption_key[i % strlen(decryption_key)];\n        }\n        std::cout << \"decrypted data of source node: \" << received_message << std::endl;\n        receivedPackets++;\n\n        bool shouldForward =  false;\n        printf(\"{BLACKHOLE} IS RELAY FORWARDING [PACKET NUMBER %d] ?? %s\\n\",forwardedPackets,shouldForward?\"YES\":\"NO\");\n        char encryptionKeyDestination[] = \"anothersecret\";\n        if(shouldForward){\n            forwardedPackets++;\n            // re-encrypt message with destination key\n            for (int i = 0; i < bytes_received; i++) {\n                received_message[i] = received_message[i] ^ encryptionKeyDestination[i % strlen(encryptionKeyDestination)];\n            }\n\n            // forward it ahead\n            send(destination_socket, received_message, bytes_received, 0);\n            std::cout << \"Forward the encrypted data to the destination node\" <<std::endl;\n        }\n\n        // send ack to source\n        char message[] = \"Data forwarded to destination node\";\n        for (int i = 0; i < strlen(message); i++) {\n            message[i] = message[i] ^ encryptionKeyDestination[i % strlen(encryptionKeyDestination)];\n        }\n        send(source_socket, message, strlen(message), 0);\n\n        printf(\n                \"SUMMARY: RECEIVED-PACKETS(%d)|FORWARDED-PACKETS(%d)|DROPPED-PACKETS(%d)|RATIO(%f)\\n\",\n                receivedPackets,\n                forwardedPackets,\n                receivedPackets-forwardedPackets,\n                ((float)(receivedPackets-forwardedPackets))/receivedPackets\n        );\n\n        sleep(1);\n    }\n\n    // close sockets\n    close(destination_socket);\n    close(source_socket);\n    close(relay_socket);\n\n    return 0;\n}\n\n\nlab7-blackhole_attack-source.cpp\n// Requires ssl and crypto libraries via -l flag\n#include <iostream>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <cstring>\n#include <arpa/inet.h>\n\nint main() {\n    // Define the relay node address\n    struct sockaddr_in relay_node_address;\n    relay_node_address.sin_family = AF_INET;\n    relay_node_address.sin_port = htons(1234);\n    inet_pton(AF_INET, \"127.0.0.1\", &relay_node_address.sin_addr);\n\n    // connect to relay node\n    int source_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (connect(source_socket, (struct sockaddr*) &relay_node_address, sizeof(relay_node_address))==-1)\n    {\n        printf(\"SOURCE CONNECTION TO RELAY ERROR IN CONNECT...\");\n        exit(1);\n    }\n\n    int messageNumber = 0;\n    while (true) {\n        ++messageNumber;\n        // send encrypted message\n        char message[100];\n        sprintf(message,\"%d\",messageNumber);\n        std::cout << \"source node will send this message=>|\" << message  << \"|\" << std::endl;\n        char encryption_key[] = \"secret\";\n        for (int i = 0; i < strlen(message); i++) {\n            message[i] = message[i] ^ encryption_key[i % strlen(encryption_key)];\n        }\n        std::cout << \"send this encrypted data to relay node: \" << message << std::endl;\n        std::cout << send(source_socket, message, strlen(message), 0) << std::endl;\n        // receive encrypted data from relay node...\n        char received_message[1024];\n        memset(received_message, 0, sizeof(received_message));\n        int bytes_received = recv(source_socket, received_message, sizeof(received_message), 0);\n\n        // decrypt acknowledgement\n        for (int i = 0; i < bytes_received; i++) {\n            received_message[i] = received_message[i] ^ encryption_key[i % strlen(encryption_key)];\n        }\n\n        std::cout << \"Received acknowledgment from relay node: \" << received_message << std::endl;\n        sleep(1);\n    }\n\n    // terminate socket\n    close(source_socket);\n    return 0;\n}\nlab7-grayhole_attack-destination.cpp\n// Requires ssl and crypto libraries via -l flag\n#include <iostream>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <cstring>\n#include <arpa/inet.h>\n#include <unistd.h>\n\n\n// SYMMETRIC KEY ENCRYPTION AND DECRYPTION\nvoid encrypt(char *data, int data_len, const char *encryption_key) {\n    for (int i = 0; i < data_len; i++) {\n        data[i] = data[i] ^ encryption_key[i % strlen(encryption_key)];\n    }\n}\n\nint main() {\n    // RELAY NODE SOCKET\n    struct sockaddr_in relay_node_address;\n    relay_node_address.sin_port = htons(5678);\n    relay_node_address.sin_family = AF_INET;\n    inet_pton(AF_INET, \"127.0.0.1\", &relay_node_address.sin_addr);\n\n    // CONNECT TO RELAY\n    int destination_socket = socket(AF_INET, SOCK_STREAM, 0);\n    bind(destination_socket, (struct sockaddr *) &relay_node_address, sizeof(relay_node_address));\n\n    // Listen for incoming connections from the relay node\n    listen(destination_socket, 5);\n    std::cout << \"Waiting for incoming connections from relay node...\" << std::endl;\n\n    // Accept incoming connection from the relay node\n    struct sockaddr_in relay_node_address_client;\n    socklen_t client_address_size = sizeof(relay_node_address_client);\n    int relay_node_socket = accept(destination_socket, (struct sockaddr *) &relay_node_address_client,\n                                   &client_address_size);\n    std::cout << \"Received connection from relay node \" << inet_ntoa(relay_node_address_client.sin_addr) << \":\"\n              << ntohs(relay_node_address_client.sin_port) << std::endl;\n\n    while(1) {\n        // Receive encrypted data from the relay node\n        char received_message[1024];\n        memset(received_message, 0, sizeof(received_message));\n        int bytes_received = recv(relay_node_socket, received_message, sizeof(received_message), 0);\n        std::cout << \"receive encrypted data from relay node: \" << received_message << std::endl;\n\n        // Decrypt the received data\n        char decryption_key[] = \"anothersecret\";\n        encrypt(received_message, bytes_received, decryption_key);\n        std::cout << \"Received message from relay node:\" << received_message << std::endl;\n\n        // Send encrypted acknowledgment to the relay node\n        char message[] = \"Acknowledgment from destination node!\";\n        encrypt(message, strlen(message), decryption_key);\n        send(relay_node_socket, message, strlen(message), 0);\n        sleep(1);\n    }\n\n    return 0;\n}\nlab7-grayhole_attack-relay.cpp\n// Requires ssl and crypto libraries via -l flag\n#include <iostream>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <cstring>\n#include <arpa/inet.h>\n#include <random>\nint main() {\n    // source\n    struct sockaddr_in source_node_address;\n    source_node_address.sin_family = AF_INET;\n    source_node_address.sin_port = htons(1234);\n    inet_pton(AF_INET, \"127.0.0.1\", &source_node_address.sin_addr);\n\n    // destination\n    struct sockaddr_in destination_node_address;\n    destination_node_address.sin_family = AF_INET;\n    destination_node_address.sin_port = htons(5678);\n    inet_pton(AF_INET, \"127.0.0.1\", &destination_node_address.sin_addr);\n\n    // connect to source\n    int relay_socket = socket(AF_INET, SOCK_STREAM, 0);\n    bind(relay_socket, (struct sockaddr*) &source_node_address, sizeof(source_node_address));\n\n    // wait till source sends message\n    listen(relay_socket, 1);\n    std::cout << \"Waiting for incoming connections from source node...\" << std::endl;\n\n    // accept connection from source\n    int source_socket = accept(relay_socket, NULL, NULL);\n    int destination_socket = socket(AF_INET, SOCK_STREAM, 0);\n    connect(destination_socket, (struct sockaddr*) &destination_node_address, sizeof(destination_node_address));\n\n    int receivedPackets = 0, forwardedPackets = 0;\n    while(true) {\n        // receive encrypted message from source\n        char received_message[1024];\n        memset(received_message, 0, sizeof(received_message));\n        int bytes_received = recv(source_socket, received_message, sizeof(received_message), 0);\n        std::cout << \"receive encrypted data from source node: \" << received_message << std::endl;\n\n        // decrypt\n        char decryption_key[] = \"secret\";\n        for (int i = 0; i < bytes_received; i++) {\n            received_message[i] = received_message[i] ^ decryption_key[i % strlen(decryption_key)];\n        }\n        std::cout << \"decrypted data of source node: \" << received_message << std::endl;\n        receivedPackets++;\n\n        bool shouldForward =  rand()&1;\n        printf(\"{GRAYHOLE}IS RELAY FORWARDING [PACKET NUMBER %d] ?? %s\\n\",forwardedPackets,shouldForward?\"YES\":\"NO\");\n        char encryptionKeyDestination[] = \"anothersecret\";\n        if(shouldForward){\n            forwardedPackets++;\n            // re-encrypt message with destination key\n            for (int i = 0; i < bytes_received; i++) {\n                received_message[i] = received_message[i] ^ encryptionKeyDestination[i % strlen(encryptionKeyDestination)];\n            }\n\n            // forward it ahead\n            send(destination_socket, received_message, bytes_received, 0);\n            std::cout << \"Forward the encrypted data to the destination node\" <<std::endl;\n        }\n\n        // send ack to source\n        char message[] = \"Data forwarded to destination node\";\n        for (int i = 0; i < strlen(message); i++) {\n            message[i] = message[i] ^ encryptionKeyDestination[i % strlen(encryptionKeyDestination)];\n        }\n        send(source_socket, message, strlen(message), 0);\n\n        printf(\n                \"SUMMARY: RECEIVED-PACKETS(%d)|FORWARDED-PACKETS(%d)|DROPPED-PACKETS(%d)|RATIO(%f)\\n\",\n                receivedPackets,\n                forwardedPackets,\n                receivedPackets-forwardedPackets,\n                ((float)(receivedPackets-forwardedPackets))/receivedPackets\n        );\n\n        sleep(1);\n    }\n\n    // close sockets\n    close(destination_socket);\n    close(source_socket);\n    close(relay_socket);\n\n    return 0;\n}\n\n\nlab7-grayhole_attack-source.cpp\n// Requires ssl and crypto libraries via -l flag\n#include <iostream>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <cstring>\n#include <arpa/inet.h>\n\nint main() {\n    // Define the relay node address\n    struct sockaddr_in relay_node_address;\n    relay_node_address.sin_family = AF_INET;\n    relay_node_address.sin_port = htons(1234);\n    inet_pton(AF_INET, \"127.0.0.1\", &relay_node_address.sin_addr);\n\n    // connect to relay node\n    int source_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (connect(source_socket, (struct sockaddr*) &relay_node_address, sizeof(relay_node_address))==-1)\n    {\n        printf(\"SOURCE CONNECTION TO RELAY ERROR IN CONNECT...\");\n        exit(1);\n    }\n\n    int messageNumber = 0;\n    while (true) {\n        ++messageNumber;\n        // send encrypted message\n        char message[100];\n        sprintf(message,\"%d\",messageNumber);\n        std::cout << \"source node will send this message=>|\" << message  << \"|\" << std::endl;\n        char encryption_key[] = \"secret\";\n        for (int i = 0; i < strlen(message); i++) {\n            message[i] = message[i] ^ encryption_key[i % strlen(encryption_key)];\n        }\n        std::cout << \"send this encrypted data to relay node: \" << message << std::endl;\n        std::cout << send(source_socket, message, strlen(message), 0) << std::endl;\n        // receive encrypted data from relay node...\n        char received_message[1024];\n        memset(received_message, 0, sizeof(received_message));\n        int bytes_received = recv(source_socket, received_message, sizeof(received_message), 0);\n\n        // decrypt acknowledgement\n        for (int i = 0; i < bytes_received; i++) {\n            received_message[i] = received_message[i] ^ encryption_key[i % strlen(encryption_key)];\n        }\n\n        std::cout << \"Received acknowledgment from relay node: \" << received_message << std::endl;\n        sleep(1);\n    }\n\n    // terminate socket\n    close(source_socket);\n    return 0;\n}\nlab7-multihop_with_encryption-destination.cpp\n// Requires ssl and crypto libraries via -l flag\n#include <iostream>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <cstring>\n#include <arpa/inet.h>\n\n\n// SYMMETRIC KEY ENCRYPTION AND DECRYPTION\nvoid encrypt(char *data, int data_len, const char *encryption_key) {\n    for (int i = 0; i < data_len; i++) {\n        data[i] = data[i] ^ encryption_key[i % strlen(encryption_key)];\n    }\n}\n\nint main() {\n    // RELAY NODE SOCKET\n    struct sockaddr_in relay_node_address;\n    relay_node_address.sin_port = htons(5678);\n    relay_node_address.sin_family = AF_INET;\n    inet_pton(AF_INET, \"127.0.0.1\", &relay_node_address.sin_addr);\n\n    // CONNECT TO RELAY\n    int destination_socket = socket(AF_INET, SOCK_STREAM, 0);\n    bind(destination_socket, (struct sockaddr *) &relay_node_address, sizeof(relay_node_address));\n\n    // Listen for incoming connections from the relay node\n    listen(destination_socket, 5);\n    std::cout << \"Waiting for incoming connections from relay node...\" << std::endl;\n\n    // Accept incoming connection from the relay node\n    struct sockaddr_in relay_node_address_client;\n    socklen_t client_address_size = sizeof(relay_node_address_client);\n    int relay_node_socket = accept(destination_socket, (struct sockaddr *) &relay_node_address_client,\n                                   &client_address_size);\n    std::cout << \"Received connection from relay node \" << inet_ntoa(relay_node_address_client.sin_addr) << \":\"\n              << ntohs(relay_node_address_client.sin_port) << std::endl;\n\n\n\n    // Receive encrypted data from the relay node\n    char received_message[1024];\n    memset(received_message, 0, sizeof(received_message));\n    int bytes_received = recv(relay_node_socket, received_message, sizeof(received_message), 0);\n    std::cout << \"receive encrypted data from relay node: \" << received_message << std::endl;\n\n    // Decrypt the received data\n    char decryption_key[] = \"anothersecret\";\n    encrypt(received_message, bytes_received, decryption_key);\n    std::cout << \"Received data from relay node:\" << received_message << std::endl;\n\n    // Send encrypted acknowledgment to the relay node\n    char message[] = \"Acknowledgment from destination node!\";\n    encrypt(message, strlen(message), decryption_key);\n    send(relay_node_socket, message, strlen(message), 0);\n\n\n    return 0;\n}\nlab7-multihop_with_encryption-relay.cpp\n// Requires ssl and crypto libraries via -l flag\n#include <iostream>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <cstring>\n#include <arpa/inet.h>\n\n\nint main() {\n    // source\n    struct sockaddr_in source_node_address;\n    source_node_address.sin_family = AF_INET;\n    source_node_address.sin_port = htons(1234);\n    inet_pton(AF_INET, \"127.0.0.1\", &source_node_address.sin_addr);\n\n    // destination\n    struct sockaddr_in destination_node_address;\n    destination_node_address.sin_family = AF_INET;\n    destination_node_address.sin_port = htons(5678);\n    inet_pton(AF_INET, \"127.0.0.1\", &destination_node_address.sin_addr);\n\n    // connect to source\n    int relay_socket = socket(AF_INET, SOCK_STREAM, 0);\n    bind(relay_socket, (struct sockaddr*) &source_node_address, sizeof(source_node_address));\n\n    // wait till source sends message\n    listen(relay_socket, 1);\n    std::cout << \"Waiting for incoming connections from source node...\" << std::endl;\n\n    // accept connection from source\n    int source_socket = accept(relay_socket, NULL, NULL);\n\n    // receive encrypted message from source\n    char received_message[1024];\n    memset(received_message, 0, sizeof(received_message));\n    int bytes_received = recv(source_socket, received_message, sizeof(received_message), 0);\n    std::cout << \"receive encrypted data from source node: \" << received_message << std::endl;\n\n    // decrypt\n    char decryption_key[] = \"secret\";\n    for (int i = 0; i < bytes_received; i++) {\n        received_message[i] = received_message[i] ^ decryption_key[i % strlen(decryption_key)];\n    }\n     std::cout << \"decrypted data of source node: \" << received_message << std::endl;\n\n    // re-encrypt message with destination key\n    char new_encryption_key[] = \"anothersecret\";\n    for (int i = 0; i < bytes_received; i++) {\n        received_message[i] = received_message[i] ^ new_encryption_key[i % strlen(new_encryption_key)];\n    }\n\n    // forward it ahead\n    int destination_socket = socket(AF_INET, SOCK_STREAM, 0);\n    connect(destination_socket, (struct sockaddr*) &destination_node_address, sizeof(destination_node_address));\n    send(destination_socket, received_message, bytes_received, 0);\n     std::cout << \"Forward the encrypted data to the destination node\" <<std::endl;\n\n    // send ack to source\n    char message[] = \"Data forwarded to destination node\";\n    for (int i = 0; i < strlen(message); i++) {\n        message[i] = message[i] ^ new_encryption_key[i % strlen(new_encryption_key)];\n    }\n    send(source_socket, message, strlen(message), 0);\n\n    // close sockets\n    close(destination_socket);\n    close(source_socket);\n    close(relay_socket);\n\n    return 0;\n}\n\n\nlab7-multihop_with_encryption-source.cpp\n// Requires ssl and crypto libraries via -l flag\n#include <iostream>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <cstring>\n#include <arpa/inet.h>\n\nint main() {\n    // Define the relay node address\n    struct sockaddr_in relay_node_address;\n    relay_node_address.sin_family = AF_INET;\n    relay_node_address.sin_port = htons(1234);\n    inet_pton(AF_INET, \"127.0.0.1\", &relay_node_address.sin_addr);\n\n    // connect to relay node\n    int source_socket = socket(AF_INET, SOCK_STREAM, 0);\n    connect(source_socket, (struct sockaddr*) &relay_node_address, sizeof(relay_node_address));\n\n    // send encrypted message\n    char message[] =\"abhishek is h\";\n    std::cout << \"source node will send this message: \" << message << std::endl;\n    char encryption_key[] = \"secret\";\n    for (int i = 0; i < strlen(message); i++) {\n        message[i] = message[i] ^ encryption_key[i % strlen(encryption_key)];\n    }\n    std::cout << \"send this encrypted data to relay node: \" << message << std::endl;\n    send(source_socket, message, strlen(message), 0);\n    // receive encrypted data from relay node...\n    char received_message[1024];\n    memset(received_message, 0, sizeof(received_message));\n    int bytes_received = recv(source_socket, received_message, sizeof(received_message), 0);\n\n    // decrypt acknowledgement\n    for (int i = 0; i < bytes_received; i++) {\n        received_message[i] = received_message[i] ^ encryption_key[i % strlen(encryption_key)];\n    }\n\n    std::cout << \"Received acknowledgment from relay node: \" << received_message << std::endl;\n\n    // terminate socket\n    close(source_socket);\n\n    return 0;\n}\n\n",
  "lab8": "\nlab8--hc.cpp\n#include <iostream>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n\n#define PORT 8080\n\nint main(int argc, char const *argv[]) {\n    int sock = 0, valread;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n    std::string input_str;\n    const char *input;\n\n    // Create socket\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return -1;\n    }\n\n    // Set server address\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(PORT);\n      \n    // Convert IPv4 and IPv6 addresses from text to binary form\n    if(inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr)<=0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        return -1;\n    }\n\n    // Connect to server\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        return -1;\n    }\n\n    // Read input from user\n    std::cout << \"Enter string to hash: \";\n    std::getline(std::cin, input_str);\n    input = input_str.c_str();\n\n    // Send data to server\n    send(sock, input, strlen(input), 0);\n    std::cout << \"Message sent to server\" << std::endl;\n\n    // Read hash result from server\n    valread = read(sock, buffer, 1024);\n    std::cout << \"Hash result: \" << buffer << std::endl;\n\n    return 0;\n}\n\n\nlab8--hs.cpp\n#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n\nusing namespace std;\n\nunsigned int simpleHash(const char* str) {\n    unsigned int hash = 0;\n    int c;\n    while (c = *str++) {\n        hash += c;\n    }\n    return hash;\n}\n\nint main() {\n    int serverSocket, clientSocket;\n    struct sockaddr_in serverAddr, clientAddr;\n    char buffer[1024];\n\n    // Create socket\n    serverSocket = socket(AF_INET, SOCK_STREAM, 0);\n    if (serverSocket < 0) {\n        cerr << \"Error: Could not create socket.\" << endl;\n        return 1;\n    }\n\n    // Bind socket to address and port\n    memset(&serverAddr, 0, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_addr.s_addr = INADDR_ANY;\n    serverAddr.sin_port = htons(8080);\n    if (bind(serverSocket, (struct sockaddr*) &serverAddr, sizeof(serverAddr)) < 0) {\n        cerr << \"Error: Could not bind socket.\" << endl;\n        return 1;\n    }\n\n    // Listen for incoming connections\n    listen(serverSocket, 5);\n    cout << \"Server listening on port 8080...\" << endl;\n\n    // Accept incoming connections\n    socklen_t clientAddrSize = sizeof(clientAddr);\n    clientSocket = accept(serverSocket, (struct sockaddr*) &clientAddr, &clientAddrSize);\n    if (clientSocket < 0) {\n        cerr << \"Error: Could not accept connection.\" << endl;\n        return 1;\n    }\n\n    // Receive message from client\n    memset(buffer, 0, sizeof(buffer));\n    int bytesRead = read(clientSocket, buffer, sizeof(buffer));\n    if (bytesRead < 0) {\n        cerr << \"Error: Could not receive message.\" << endl;\n        return 1;\n    }\n    cout << \"Received message: \" << buffer << endl;\n\n    // Hash message and send hash back to client\n    unsigned int hash = simpleHash(buffer);\n    char hashStr[32];\n    sprintf(hashStr, \"%u\", hash);\n    int bytesSent = write(clientSocket, hashStr, strlen(hashStr));\n    if (bytesSent < 0) {\n        cerr << \"Error: Could not send hash.\" << endl;\n        return 1;\n    }\n    cout << \"Sent hash: \" << hashStr << endl;\n\n    // Close sockets and exit\n    close(clientSocket);\n    close(serverSocket);\n    return 0;\n}\n\n",
  "wormhole": "// CPP code for printing shortest path between\n// two vertices of unweighted graph\n#include <bits/stdc++.h>\nusing namespace std;\n\n// utility function to form edge between two vertices\n// source and dest\nvoid add_edge(vector<int> adj[], int src, int dest)\n{\n\tadj[src].push_back(dest);\n\tadj[dest].push_back(src);\n}\n\n// a modified version of BFS that stores predecessor\n// of each vertex in array p\n// and its distance from source in array d\nbool BFS(vector<int> adj[], int src, int dest, int v,\n\t\tint pred[], int dist[])\n{\n\tlist<int> queue;\n\tbool visited[v];\n\n\t// initially all vertices are unvisited\n\t// so v[i] for all i is false\n\t// and as no path is yet constructed\n\t// dist[i] for all i set to infinity\n\tfor (int i = 0; i < v; i++) {\n\t\tvisited[i] = false;\n\t\tdist[i] = INT_MAX;\n\t\tpred[i] = -1;\n\t}\n\n\tvisited[src] = true;\n\tdist[src] = 0;\n\tqueue.push_back(src);\n\n\t// standard BFS algorithm\n\twhile (!queue.empty()) {\n\t\tint u = queue.front();\n\t\tqueue.pop_front();\n\t\tfor (int i = 0; i < adj[u].size(); i++) {\n\t\t\tif (visited[adj[u][i]] == false) {\n\t\t\t\tvisited[adj[u][i]] = true;\n\t\t\t\tdist[adj[u][i]] = dist[u] + 1;\n\t\t\t\tpred[adj[u][i]] = u;\n\t\t\t\tqueue.push_back(adj[u][i]);\n\n\t\t\t\t// We stop BFS when we find\n\t\t\t\t// destination.\n\t\t\t\tif (adj[u][i] == dest)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n// utility function to print the shortest distance\n// between source vertex and destination vertex\nvoid printShortestDistance(vector<int> adj[], int s,\n\t\t\t\t\t\tint dest, int v)\n{\n\t// predecessor[i] array stores predecessor of\n\t// i and distance array stores distance of i\n\t// from s\n\tint pred[v], dist[v];\n\n\tif (BFS(adj, s, dest, v, pred, dist) == false) {\n\t\tcout << \"Given source and destination\"\n\t\t\t<< \" are not connected\";\n\t\treturn;\n\t}\n\n\t// vector path stores the shortest path\n\tvector<int> path;\n\tint crawl = dest;\n\tpath.push_back(crawl);\n\twhile (pred[crawl] != -1) {\n\t\tpath.push_back(pred[crawl]);\n\t\tcrawl = pred[crawl];\n\t}\n\n\t// distance from source is in distance array\n\tcout << \"Shortest path length between \"<<s<<\" and \"<<dest<<\" : \"\n\t\t<< dist[dest];\n\n\t// printing path from source to destination\n\tcout << \"\nPath between \"<< s << \" and \"<<dest<<\":\n\";\n\tfor (int i = path.size() - 1; i >= 0; i--)\n\t\tcout << path[i] << \" \";\n}\n\n// Driver program to test above functions\nint main()\n{\n\t// no. of vertices\n\tint v = 50;\n\n\t// array of vectors is used to store the graph\n\t// in the form of an adjacency list\n\tvector<int> adj[v];\n\n\t// Creating graph given in the above diagram.\n\t// add_edge function takes adjacency list, source\n\t// and destination vertex as argument and forms\n\t// an edge between them.\n    for(int i=0;i<50;i++){\n        for(int j=0;j<(rand()%3)+1;j++){\n\n            int neighbour;\n            do{\n                neighbour=max(0,(i-5))+(rand()%(10));\n                neighbour=min(neighbour,49);\n                // cout<<\"neighbour: \"<<neighbour<<endl;\n            }while((neighbour==i)||(find(adj[i].begin(),adj[i].end(),neighbour)!=adj[i].end()));\n\n            add_edge(adj,i,neighbour);\n        }\n    }\n\tcout<<\"Graph and Node degree distrbution before wormhole attack:\"<<endl;\n    for(int i=0;i<v;i++){\n        cout<<i<<\" -> \";\n        for(int j=0;j<adj[i].size();j++){\n            cout<<adj[i][j]<<\" ,\";\n        }\n\t\tcout<<\" -> \"<<adj[i].size();\n        cout<<endl;\n    }\n\tcout<<\"************************************\"<<endl;\n\n\tint source=1, dest = 48;\n    // for(int i=0;i<v;i++){\n    //     if(i!=dest){\n            cout<<\"curr source is: \"<<source<<\"\ncurr destination is: \"<<dest<<endl;\n\t\t\tcout<<\"Before Wormhole:\n\";\n            printShortestDistance(adj, source, dest, v);\n            cout<<endl<<endl;\n            adj[7].push_back(40);\n            adj[40].push_back(7);\n\t\t\tcout<<\"After Wormhole:\n\";\n            printShortestDistance(adj, source, dest, v);\n            cout<<endl;\n            // adj[7].pop_back();\n            // adj[40].pop_back();\n        // }\n        cout<<\"****************************************************************\"<<endl;\n\n\t\tcout<<\"Graph and Node degree distrbution after wormhole attack:\"<<endl;\n        for(int i=0;i<v;i++){\n        cout<<i<<\" -> \";\n        for(int j=0;j<adj[i].size();j++){\n            cout<<adj[i][j]<<\" ,\";\n        }\n\t\tcout<<\" -> \"<<adj[i].size();\n        cout<<endl;\n    }\n\tcout<<\"****************************************************************\"<<endl;\n    // }\n    cout<<endl;\n\treturn 0;\n",
  "mh": "\nlabutkarsh--destination.cpp\n//how to compile- g++ -o destination destination.cpp -lssl -lcrypto\n//how to run- ./destination\n#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\n// Symmetric key encryption function\nvoid encrypt_decrypt(char* data, int data_len, const char* encryption_key) {\n    for (int i = 0; i < data_len; i++) {\n        data[i] = data[i] ^ encryption_key[i % strlen(encryption_key)];\n    }\n}\n\nint main() {\n    // Define the relay node address\n    struct sockaddr_in relay_node_address;\n    relay_node_address.sin_family = AF_INET;\n    relay_node_address.sin_port = htons(5678);\n    inet_pton(AF_INET, \"127.0.0.1\", &relay_node_address.sin_addr);\n\n    // Create a socket and bind it to the relay node address\n    int destination_socket = socket(AF_INET, SOCK_STREAM, 0);\n    bind(destination_socket, (struct sockaddr*) &relay_node_address, sizeof(relay_node_address));\n\n    // Listen for incoming connections from the relay node\n    listen(destination_socket, 5);\n    std::cout << \"Waiting for incoming connections from relay node...\" << std::endl;\n\n    // Accept incoming connection from the relay node\n    struct sockaddr_in relay_node_address_client;\n    socklen_t client_address_size = sizeof(relay_node_address_client);\n    int relay_node_socket = accept(destination_socket, (struct sockaddr*) &relay_node_address_client, &client_address_size);\n    std::cout << \"Received connection from relay node \" << inet_ntoa(relay_node_address_client.sin_addr) << \":\" << ntohs(relay_node_address_client.sin_port) << std::endl;\n\n    // Receive encrypted data from the relay node\n    char received_message[1024];\n    memset(received_message, 0, sizeof(received_message));\n    int bytes_received = recv(relay_node_socket, received_message, sizeof(received_message), 0);\n    std::cout << \"recieve encrpypted data from relay node: \" << received_message << std::endl;\n    \n    \n    // Decrypt the received data\n    char decryption_key[] = \"mynewsecretkey\";\n    encrypt_decrypt(received_message, bytes_received, decryption_key);\n    std::cout << \"Received data from relay node:\" << received_message << std::endl;\n\n    // Send encrypted acknowledgment to the relay node\n    char message[] = \"Acknowledgment from destination node!\";\n    encrypt_decrypt(message, strlen(message), decryption_key);\n    send(relay_node_socket, message, strlen(message), 0);\n\n    // Close the sockets\n    close(relay_node_socket);\n    close(destination_socket);\n\n    return 0;\n}\n\n\nlabutkarsh--relay.cpp\n//how to compile-g++ -o relay relay.cpp -lssl -lcrypto\n//how to run- ./relay\n#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint main() {\n    // Define the source node address\n    struct sockaddr_in source_node_address;\n    source_node_address.sin_family = AF_INET;\n    source_node_address.sin_port = htons(1234);\n    inet_pton(AF_INET, \"127.0.0.1\", &source_node_address.sin_addr);\n\n    // Define the destination node address\n    struct sockaddr_in destination_node_address;\n    destination_node_address.sin_family = AF_INET;\n    destination_node_address.sin_port = htons(5678);\n    inet_pton(AF_INET, \"127.0.0.1\", &destination_node_address.sin_addr);\n\n    // Create a socket and bind it to the relay node address\n    int relay_socket = socket(AF_INET, SOCK_STREAM, 0);\n    bind(relay_socket, (struct sockaddr*) &source_node_address, sizeof(source_node_address));\n\n    // Listen for incoming connections from the source node\n    listen(relay_socket, 1);\n    std::cout << \"Waiting for incoming connections from source node...\" << std::endl;\n\n    // Accept the connection from the source node\n    int source_socket = accept(relay_socket, NULL, NULL);\n\n    // Receive encrypted data from the source node\n    char received_message[1024];\n    memset(received_message, 0, sizeof(received_message));\n    int bytes_received = recv(source_socket, received_message, sizeof(received_message), 0);\n    std::cout << \"receive encrpypted data from source node: \" << received_message << std::endl;\n\n    // Decrypt the received data\n    char decryption_key[] = \"mysecretkey\";\n    for (int i = 0; i < bytes_received; i++) {\n        received_message[i] = received_message[i] ^ decryption_key[i % strlen(decryption_key)];\n    }\n     std::cout << \"decrpypted data of source node: \" << received_message << std::endl;\n\n    // Re-encrypt the data with a new key\n    char new_encryption_key[] = \"mynewsecretkey\";\n    for (int i = 0; i < bytes_received; i++) {\n        received_message[i] = received_message[i] ^ new_encryption_key[i % strlen(new_encryption_key)];\n    }\n\n    // Forward the encrypted data to the destination node\n    int destination_socket = socket(AF_INET, SOCK_STREAM, 0);\n    connect(destination_socket, (struct sockaddr*) &destination_node_address, sizeof(destination_node_address));\n    send(destination_socket, received_message, bytes_received, 0);\n     std::cout << \"Forward the encrypted data to the destination node\" <<std::endl;\n\n    // Send encrypted acknowledgment to the source node\n    char message[] = \"Data forwarded to destination node\";\n    for (int i = 0; i < strlen(message); i++) {\n        message[i] = message[i] ^ new_encryption_key[i % strlen(new_encryption_key)];\n    }\n    send(source_socket, message, strlen(message), 0);\n\n    // Close the sockets\n    close(destination_socket);\n    close(source_socket);\n    close(relay_socket);\n\n    return 0;\n}\n\n\nlabutkarsh--source.cpp\n//how to compile-g++ -o source source.cpp -lssl -lcrypto\n//how to run- ./source\n#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint main() {\n    // Define the relay node address\n    struct sockaddr_in relay_node_address;\n    relay_node_address.sin_family = AF_INET;\n    relay_node_address.sin_port = htons(1234);\n    inet_pton(AF_INET, \"127.0.0.1\", &relay_node_address.sin_addr);\n\n    // Create a socket and connect to the relay node\n    int source_socket = socket(AF_INET, SOCK_STREAM, 0);\n    connect(source_socket, (struct sockaddr*) &relay_node_address, sizeof(relay_node_address));\n\n    // Send encrypted data to the relay node\n    char message[] =\"Hii Utkarsh\";\n    std::cout << \"source node will send this message: \" << message << std::endl;\n    char encryption_key[] = \"mysecretkey\";\n    for (int i = 0; i < strlen(message); i++) {\n        message[i] = message[i] ^ encryption_key[i % strlen(encryption_key)];\n    }\n    std::cout << \"send this encrpypted data to relay node: \" << message << std::endl;\n    send(source_socket, message, strlen(message), 0);\n\n    // Receive encrypted acknowledgment from the relay node\n    \n    char received_message[1024];\n    memset(received_message, 0, sizeof(received_message));\n    int bytes_received = recv(source_socket, received_message, sizeof(received_message), 0);\n\n    // Decrypt the received acknowledgment\n    for (int i = 0; i < bytes_received; i++) {\n        received_message[i] = received_message[i] ^ encryption_key[i % strlen(encryption_key)];\n    }\n\n    std::cout << \"Received acknowledgment from relay node: \" << received_message << std::endl;\n\n    // Close the socket\n    close(source_socket);\n\n    return 0;\n}\n\n"
}

def Convolve(a=None):
    if not a or a not in codes:
        print(codes['index'])
    else:
        print(codes[a])
