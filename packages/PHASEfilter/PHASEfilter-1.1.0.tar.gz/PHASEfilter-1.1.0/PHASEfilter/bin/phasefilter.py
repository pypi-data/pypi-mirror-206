#!/usr/bin/env python3
# encoding: utf-8
'''
phasefilter.py_ -- shortdesc

phasefilter.py is a description


@author:	 mmp

@copyright:  2019 iBiMED. All rights reserved.

@license:	license

@contact:	monsanto@ua.pt
@deffield	updated: Updated
'''
from PHASEfilter.lib.utils.util import Utils
from PHASEfilter.lib.process.process_genomes import ProcessTwoGenomes
from PHASEfilter.lib.utils.vcf_process import VcfProcess
from PHASEfilter.lib.utils.software import Software
from PHASEfilter.lib.constants import version
import os, re, sys

# export PYTHONPATH='/home/mmp/git/PHASEfilter'
# python3 phasefilter.py 
#   --ref1 /home/projects/ua/candida/compare_A_vs_B/ref/genomeA/Ca22chr1A_C_albicans_SC5314.fasta 
#	--ref2 /home/projects/ua/candida/compare_A_vs_B/ref/genomeB/Ca22chr1B_C_albicans_SC5314.fasta
#	--vcf1 /home/projects/ua/candida/compare_A_vs_B/vcf/A-M_S4/A-M_S4_chrA_filtered_snps.vcf.gz
#	--vcf2 /home/projects/ua/candida/compare_A_vs_B/vcf/A-M_S4/A-M_S4_chrB_filtered_snps.vcf.gz
#	--out_dir /home/projects/ua/candida/compare_A_vs_B
# python3 phasefilter.py --ref1 /home/projects/ua/candida/compare_A_vs_B/ref/genomeA/Ca22chr1A_C_albicans_SC5314.fasta --ref2 /home/projects/ua/candida/compare_A_vs_B/ref/genomeB/Ca22chr1B_C_albicans_SC5314.fasta --vcf1 /home/projects/ua/candida/compare_A_vs_B/vcf/T1_Fluc_5/T1_Fluc_5_chrA_filtered_snps.vcf.gz --vcf2 /home/projects/ua/candida/compare_A_vs_B/vcf/T1_Fluc_5/T1_Fluc_5_chrB_filtered_snps.vcf.gz --out /home/projects/ua/candida/compare_A_vs_B

# --chain_A_B /home/projects/ua/candida/chain/Assembly22_hapA_To_Assembly22_hapB.over.chain --chain_B_A /home/projects/ua/candida/chain/Assembly22_hapB_To_Assembly22_hapA.over.chain
# python3 -m unittest -v tests.test_vcf

# https://mbio.asm.org/content/9/5/e01205-18#sec-12
# https://www.nature.com/articles/s41467-018-04787-4.pdf?origin=ppub
from optparse import OptionParser

__all__ = []
__version__ = version.VERSION_phase_filter
__date__ = '2020-05-01'
__updated__ = '2021-09-06'

utils = Utils()

def checkRequiredArguments(opts, parser):
	missing_options = []
	for option in parser.option_list:
		if re.match(r'^\[REQUIRED\]', option.help) and eval('opts.' + option.dest) == None:
			missing_options.extend(option._long_opts)
	if len(missing_options) > 0:
		parser.error('Missing REQUIRED parameters: ' + str(missing_options))


def make_ref_from_to_ref_to(reference_1, reference_2, vcf_1, vcf_2,
					threshold_heterozygous_ad, remove_variants_by_AD_ratio, outfile_vcf, chain_from_to):
	"""
	Process from one Ref to Other
	"""
	process_two_genomes = ProcessTwoGenomes(reference_1, reference_2, vcf_1, vcf_2,
				threshold_heterozygous_ad, remove_variants_by_AD_ratio, outfile_vcf,
				chain_from_to)
	print("outfile report file = %s" % process_two_genomes.get_report_file())
	print("outfile valid variants = %s" % process_two_genomes.outfile_vcf)
	print("outfile removed variants = %s" % process_two_genomes.get_vcf_removed_file())
	print("outfile LOH variants = %s" % process_two_genomes.get_vcf_loh_file())
	
	### test all software needed to run this script
	software = Software()
	software.test_softwares()
	
	### test output file
	if (os.path.exists(outfile_vcf)):
		read_input = input("Output file '{}' already exist, do you want to replace it? [y|Y]".format(outfile_vcf))
		if (len(read_input.strip()) > 0 and read_input.upper() != 'Y'): sys.exit("Exit by the user.")
		
	## make dir if does not exist
	process_two_genomes.process()
	

def main(argv=None):
	'''Command line options.'''
	
	program_name = os.path.basename(sys.argv[0])
	program_version = "{}".format(__version__)
	program_build_date = "%s" % __updated__

	program_version_string = '%%prog %s (%s)' % (program_version, program_build_date)
	#program_usage = '''usage: spam two eggs''' # optional - will be autogenerated by optparse
	program_longdesc = '''Identifies heterozygous variations and create three files: 1) valid; 2) heterozygous variants; 3) loss of heterozygous (LOH).
	It accept 5 mandatory parameters and three optional parameters.
	It will work in both directions, from REF1 to REF2 and then from REF2 to REF1.
	It is possible to pass the chain to avoid creation of synchronization
	''' # optional - give further explanation about what the program does
	program_license = "Copyright 2020 (iBiMED)											\
				Licensed under the MIT\nhttps://spdx.org/licenses/MIT.html"

	if argv is None:
		argv = sys.argv[1:]
	
		# setup option parser
		parser = OptionParser(version=program_version_string, epilog=program_longdesc, description=program_license)
		parser.add_option("--ref1", dest="reference_1", help="[REQUIRED] reference for genome 1", metavar="FILE")
		parser.add_option("--ref2", dest="reference_2", help="[REQUIRED] reference for genome 2", metavar="FILE")
		parser.add_option("--vcf1", dest="vcf_1", help="[REQUIRED] vcf of genome 1", metavar="FILE")
		parser.add_option("--vcf2", dest="vcf_2", help="[REQUIRED] vcf of genome 2", metavar="FILE")
		parser.add_option("--chain_A_B", dest="chain_A_B", help="[Optional] chain from genome 1 to genome 2", metavar="FILE", default=None)
		parser.add_option("--chain_B_A", dest="chain_B_A", help="[Optional] chain from genome 2 to genome 1", metavar="FILE", default=None)
		parser.add_option("--out", dest="out_dir", help="[REQUIRED] paths to write the VCF files", metavar="PATH")
		## The reason to use AD is because GATK defines predefine values for AF = 0.5/1 and AC = 1|2. Doesn't reflect the real values of AD  
		parser.add_option("--threshold_heterozygous_AD", dest="threshold_heterozygous_ad", help="Cutoff ratio of Allelic depths for the alt alleles " +\
						" in the order listed. If bigger than this level is considered homozygous. If = to -1 it is not going to take it into account", metavar="RATIO", type="float", default=-1.0)
		parser.add_option("--remove_variants_by_AD_ratio", dest="remove_variants_by_AD_ratio", help="Cutoff ratio of Allelic depths to remove variants. " +\
						"It will be applied to 'vcf1'. If = to -1 it is not going to take it into account", metavar="RATIO", type="float", default=-1.0)

		# process options
		(opts, args) = parser.parse_args(argv)
		checkRequiredArguments(opts, parser)
		
		### output directoru		
		## valid_[A|B]_to_[B|A].vcf”, “removed_[A|B]_to_[B|A].vcf” and “loss_of_heterozygous_[A|B]_to_[B|A].vcf
		if opts.reference_1: 	print("reference 1                = %s" % opts.reference_1)
		if opts.reference_2: 	print("reference 2                = %s" % opts.reference_2)
		if opts.vcf_1: 			print("vcf 1                      = %s" % opts.vcf_1)
		if opts.vcf_2: 			print("vcf 2                      = %s" % opts.vcf_2)
		if opts.out_dir:	 	print("out_dir                    = %s" % opts.out_dir)
		if (opts.threshold_heterozygous_ad and opts.threshold_heterozygous_ad != -1):
								print("threshold heterozygous     = {:.2f}".format(opts.threshold_heterozygous_ad))
		if (opts.remove_variants_by_AD_ratio and opts.remove_variants_by_AD_ratio != -1):
								print("remove variant by AD ratio = {:.2f}".format(opts.remove_variants_by_AD_ratio))
		if (opts.chain_A_B):    print("Chain from A to B          = {}".format(opts.chain_A_B))
		if (opts.chain_B_A):    print("Chain from B to A          = {}".format(opts.chain_B_A))
		if (opts.reference_1 == opts.reference_2): sys.exit("Error: you have the same reference file")
		if (opts.chain_A_B and opts.chain_B_A and opts.chain_A_B == opts.chain_B_A): sys.exit("Error: you have the same chain file for different directions")

		### testing files
		utils.test_file_exists(opts.reference_1)
		utils.test_file_exists(opts.reference_2)
		utils.test_file_exists(opts.vcf_1)
		utils.test_file_exists(opts.vcf_2)
		if (opts.chain_A_B): utils.test_file_exists(opts.chain_A_B)
		if (opts.chain_B_A): utils.test_file_exists(opts.chain_B_A)

		#### Test reference
		b_print_results = False
		threshold_ad = 0.05
		threshold_remove_variant_ad = 0.05
		vcf_process_1 = VcfProcess(opts.vcf_1, threshold_ad, threshold_remove_variant_ad, b_print_results)
		if (vcf_process_1.exist_meta_data_tag('reference')):
			if (not vcf_process_1.exist_reference_name(opts.reference_1)):
				print("Warning: 'VCF_1' has a different reference name'{}' from 'reference_1': {}".
					format(vcf_process_1.get_reference_name(), opts.reference_1.split('/')[-1]))
				
		vcf_process_2 = VcfProcess(opts.vcf_2, threshold_ad, threshold_remove_variant_ad, b_print_results)
		if (vcf_process_2.exist_meta_data_tag('reference')):
			if (not vcf_process_2.exist_reference_name(opts.reference_2)):
				print("Warning: 'VCF_2' has a different reference name'{}' from 'reference_2': {}".
					format(vcf_process_2.get_reference_name(), opts.reference_2.split('/')[-1]))

		### test if the VCF file has the AF info tag
		if not vcf_process_1.has_info('AC') and opts.threshold_heterozygous_ad == -1.0:
			print("Error: your file '{}' does not have AC info tag.".format(opts.vcf_1))
			if (not vcf_process_1.has_format('AC')): print("Please, provide a file with this field.".format(opts.vcf_1))
			else: print("Please, define a threshold in the parameter 'threshold_heterozygous_ad'.")
			exit(1)
			
		#### Test if AD is present in 1 and 2
		if (opts.threshold_heterozygous_ad != -1.0):	### test AD
			if (not vcf_process_1.has_format('AD')):
				print("Warning: Format tag 'AD' is not present in file '{}'. 'threshold_heterozygous_ad' will be disable...".format(opts.vcf_1)) 
				opts.threshold_heterozygous_ad = -1.0
			
			if (opts.threshold_heterozygous_ad != -1.0):
				if (not vcf_process_2.has_format('AD')):
					print("Warning: Format tag 'AD' is not present in file '{}'. 'threshold_heterozygous_ad' will be disable...".format(opts.vcf_2))  
					opts.threshold_heterozygous_ad = -1.0

		### test chain file names
		if (opts.chain_A_B and opts.chain_B_A and opts.chain_A_B == opts.chain_B_A):
			print("Error: chain file A to B is the same as B to A.")
			exit(1)

		### make path if not exist
		utils.make_path(opts.out_dir)
		
		## make ref1 to ref2
		outfile_vcf = os.path.join(opts.out_dir, "{}_TO_{}.vcf.gz".format(
					utils.get_file_name_without_extension(opts.reference_1),
					utils.get_file_name_without_extension(opts.reference_2)))
		make_ref_from_to_ref_to(opts.reference_1, opts.reference_2, opts.vcf_1, opts.vcf_2,
				opts.threshold_heterozygous_ad, opts.remove_variants_by_AD_ratio, outfile_vcf, opts.chain_A_B)

		## make ref2 to ref1
		outfile_vcf = os.path.join(opts.out_dir, "{}_TO_{}.vcf.gz".format(
					utils.get_file_name_without_extension(opts.reference_2),
					utils.get_file_name_without_extension(opts.reference_1)))
		make_ref_from_to_ref_to(opts.reference_2, opts.reference_1, opts.vcf_2, opts.vcf_1,
				opts.threshold_heterozygous_ad, opts.remove_variants_by_AD_ratio, outfile_vcf, opts.chain_B_A)

		print("Done. Outputs in '{}'".format(opts.out_dir))

if __name__ == "__main__":

	sys.exit(main())


